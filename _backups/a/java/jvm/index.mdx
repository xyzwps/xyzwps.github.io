---
layout: ./_BlogLayout.astro
title: JVM
---

- JVM 结构
  - TODO:
- GC 主要工作
  - 分配内存
  - 保证被引用的对象在内存中
  - 清理不可达对象。不可达对象也被称为垃圾。整个清理过程被称为垃圾回收
- 内存空间分代
  - 每个代中存放着年龄不同的对象
  - 分代假说：
    - 假说内容
      - 大多数对象在年轻时就成了垃圾
      - 老对象很少持有对年轻对象的引用
    - 根据假说，堆内存被分成两个代
      - 年轻代(Young): 空间占用较小，GC 较为频繁（Minor GC）
      - 老年代(Old, Tenured): 空间占用较大，并且缓慢增长 (Major GC, Full GC)
    - 其他内存区域
      - 方法区
        - J8 之前叫永久代(Permanent Generation)
        - J8 及其之后叫元空间（Metaspace）
        - 使用选项 `MaxMetaspaceSize` 限制大小
        - 选项 `UseCompressedClassesPointers` TODO: 啥意思
      - Code Cache: JIT 编译器存放编译后代码的地方
      - Native memory: 系统内存，不由 JVM 管理
- GC 算法
  - G1 之前
    - 年轻代 GC
      - Serial: STW，COPY 收集器，单线程
      - ParNew: STW, COPY 收集器，多线程
      - Parallel Scavenge: STW, COPY 收集器，多线程 TODO: 和 parnew 的区别
    - 老年代 GC
      - Serial Old: STW, MSC（mark-sweep-compact） 收集器，单线程
      - CMS: 多数情况并发，低暂停收集器。并发失败退回到 Serial Old TODO: 废弃
      - Parallel Old: 压缩收集器，多线程
    - 选项
      - `UseSerialGC`: Serial + Serial Old
      - `UseParNewGC`: ParNew + Serial Old
      - `UseConcMarkSweepGC`: ParNew + CMS + Serial Old
      - `UseParallelGC`: Parallel Scavenge + Parallel Old
    - 年轻代空间
      - Eden: 新对象总是在此分配内存
      - Survivor To:
        - GC 后 Eden 和 Survivor From 中剩下的对象被搬到这里
        - To 空间不够大怎么办 TODO:
      - Survivor From:
        - Survivor From 足够老的对象被搬到 Old Gen
        - 被搬空后，To 和 From 互换名字
    - Mark-Sweep-Compact
      - Mark 阶段: 找出所有的活对象
      - Sweep 阶段: 清理堆中垃圾
      - Compacht 阶段: 把活对象对齐到堆空间开头
    - Concurrent Mark Sweep TODO: 算法
      - Low-latency collector, Mostly concurrent
      - No heap compaction – fragmentation
      - Free lists link unallocated regions
      - Allocations expensive as compared to bump-the-pointer allocations
      - Additional overhead on young collections
      - Larger heap size requirement and floating garbage
      - Deprecated in Java 9
  - G1
  - ZGC
    - 使用 `UseZGC`
- 工具
  - Java Mission Control TODO: 如何使用
  - 



## 参考

- [Java GC Tutorials - Herong's Tutorial Examples](https://www.herongyang.com/Java-GC/index.html)
- [Oracle JVM Garbage Collectors Available From JDK 1.7.0_04 And After - Fasterj](http://www.fasterj.com/articles/oraclecollectors1.shtml)
- [Java Platform Standard Edition 8 Documentation](https://docs.oracle.com/javase/8/docs/)
- [tschatzl@github](https://tschatzl.github.io/)
- [JDK Tool Spec](https://docs.oracle.com/en/java/javase/20/docs/specs/man/index.html)
- [OpenJDK Wiki](https://wiki.openjdk.org/)
- [https://dev.java](https://dev.java/)
- [https://openjdk.org/](https://openjdk.org/)
- [HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/en/java/javase/20/gctuning/)
- [The Java HotSpot Performance Engine Architecture](https://www.oracle.com/java/technologies/whitepaper.html)
- [The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/index.html)
- [G1: One Garbage Collector To Rule Them All](https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All/)
- [JVM Troubleshooting MOOC: Troubleshooting Memory Issues in Java Applications](https://www.oracle.com/webfolder/technetwork/tutorials/mooc/JVM_Troubleshooting/week1/lesson1.pdf)
- [The Garbage Collection Handbook: The art of automatic memory management](http://www.gchandbook.org/index.html)
