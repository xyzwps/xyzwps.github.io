---
title: Choreography Pattern
translateFrom: https://docs.microsoft.com/en-us/azure/architecture/patterns/choreography
---

让系统的每个组件参与关于业务事务工作流的决策过程，而不是依赖于一个中心控制点。

# 问题背景

在微服务架构中，基于云的应用程序通常被划分为几个小型服务，这些服务协同工作以处理端到端的业务事务。
为了降低服务之间的耦合，每个服务负责单个业务操作。一些好处包括更快的开发、更小的代码库和可伸缩性。
然而，设计一个高效且可伸缩的工作流是一个挑战，通常需要复杂的服务间通信。

服务之间通过使用定义良好的 API 进行通信。即使单个业务操作也可能导致所有服务之间的多个点对点调用。
通信的一种常见模式是使用作为协调器（orchestrator）的集中式服务。它确认所有传入的请求，并将操作委托给相应的服务。
在这样做的同时，它还管理整个业务事务的工作流。每个服务只完成一个操作，并不知道整个工作流。

协调器模式减少了服务之间的点到点通信，但是由于协调器和参与业务事务处理的其他服务之间的紧耦合，它有一些缺点。
要按顺序执行任务，协调器需要了解有关这些服务的职责的一些领域知识。
如果您想要添加或删除服务，现有的逻辑将会中断，您将需要重新连接通信路径的某些部分。
虽然您可以使用设计良好的协调器轻松地配置工作流，添加或删除服务，但是这样的实现非常复杂且难以维护。

![orchestrator](/asset/img/orchestrator.png)

# 解决方案

让每个服务决定何时以及如何处理业务操作，而不是依赖于中央协调器。

实现编排的一种方法是使用异步消息模式（TODO: 连接到发布订阅模式）来协调业务操作。

![choreography pattern](/asset/img/choreography-pattern.png)

客户端请求将消息发布到消息队列。当消息到达时，它们被推送到对该消息感兴趣的订阅者或服务。
每个订阅的服务执行消息所指示的操作，并在操作成功或失败时响应消息队列。
如果成功，服务可以将消息推回到同一个队列或不同的消息队列，以便其他服务可以在需要时继续工作流。
如果操作失败，消息总线可以重试该操作。

通过这种方式，服务在它们之间编排工作流，而不依赖于协调器或它们之间的直接通信。

因为没有点到点的通信，这种模式有助于减少服务之间的耦合。此外，它还可以消除协调器在处理所有事务时造成的性能瓶颈。

# 何时使用

如果希望频繁地更新、删除或添加新服务，请使用编排模式。要对对整个应用程序进行修改，只需要较少的努力，并且对可以最小化对现有服务的破坏。

如果在中央协调器中遇到性能瓶颈，请考虑此模式。

此模式是无服务器体系结构的自然模型，其中所有服务都可以是短期的或事件驱动的。
服务可以因为一个事件而旋转起来，执行它们的任务，并在任务完成时被删除。

# 问题与注意事项

分散协调器可能会在管理工作流时导致问题。

如果服务未能完成业务操作，则可能难以从该故障中恢复。
一种方法是让服务通过触发事件来指示失败。
订阅这些失败事件的另一个服务采取必要的操作，例如应用补偿事务（TODO: 链接到补偿事务模式）来撤消请求中的成功操作。
失败的服务也可能无法为失败触发事件。在这种情况下，考虑使用重试和(或)超时机制将该操作识别为失败。
有关示例，请参见示例部分。

当您希望并行处理独立的业务操作时，实现工作流很简单。您可以使用单个消息总线。
然而，当需要按顺序进行编排时，工作流可能会变得复杂。例如，服务 C 只有在服务 A 和服务 B 成功完成其操作之后才能启动其操作。
一种方法是使用多个消息总线以所需的顺序获取消息。有关更多信息，请参见示例部分。

如果服务的数量快速增长，编排模式就会成为一个挑战。由于独立移动部件的数量很多，服务之间的工作流往往变得复杂。
此外，分布式跟踪变得很困难。

协调器集中管理工作流的弹性，它可以成为单点故障。另一方面，对于编排，角色在所有服务之间分布，弹性变得不那么健壮。

每个服务不仅要对其操作的弹性负责，还要对工作流负责。这种责任可能会给服务带来负担，并且难以实现。
每个服务必须重试瞬态、非瞬态和超时故障，以便在需要时优雅地终止请求。
此外，服务必须努力传达操作的成功或失败，以便其他服务能够相应地采取行动。

