---
title: 网关聚合模式
translateFrom: https://docs.microsoft.com/en-us/azure/architecture/patterns/gateway-aggregation
---

使用网关将多个单个请求聚合为单个请求。
当客户端必须对不同的后端系统进行多次调用以执行操作时，此模式非常有用。

# 问题背景

要执行单个任务，客户端可能必须对各种后端服务进行多次调用。
依赖于许多服务来执行任务的应用程序必须在每个请求上消耗资源。
当任何新的特性或服务被添加到应用程序中时，需要额外的请求，进一步增加资源需求和网络调用。
客户端和后端之间的这种通信可能会对应用程序的性能和规模产生不利影响。
微服务体系结构使这个问题变得更加普遍，因为围绕许多小型服务构建的应用程序自然会有更多的跨服务调用。

在下图中，客户机向每个服务发送请求(1、2、3)。
每个服务处理请求并将响应发送回应用程序(4、5、6)。
在通常延迟较高的蜂窝网络上，以这种方式使用单个请求效率低下，可能导致连接中断或请求不完整。
虽然每个请求可以并行执行，但是应用程序必须发送、等待和处理每个请求的数据，
所有这些都在单独的连接上，这增加了失败的可能性。

![gateway-aggregation-problem](/asset/img/gateway-aggregation-problem.png)

# 解决方案

使用网关来减少客户端和服务之间的通信量。网关接收客户端请求，将请求分派到各个后端系统，
然后聚合结果并将其发送回请求客户端。

此模式可以减少应用程序向后端服务发出的请求数量，并提高高延迟网络上的应用程序性能。

在下图中，应用程序向网关(1)发送请求。请求包含一个附加请求的包。
网关对这些请求进行分解，并通过将请求发送到相关服务(2)来处理每个请求。
每个服务返回对网关的响应(3)。网关组合了来自每个服务的响应，并将响应发送给应用程序(4)。
应用程序发出单个请求，并且只从网关接收单个响应。

![gateway-aggregation](/asset/img/gateway-aggregation.png)

# 问题与注意事项

* 网关不应该在后端服务之间引入服务耦合。
* 网关应该位于后端服务附近，以尽可能减少延迟。
* 网关服务可能会引入单点故障。确保网关的设计正确，以满足应用程序的可用性需求。
* 网关可能会引入一个瓶颈。确保网关具有足够的性能来处理负载，并且可以按比例扩展以满足您的预期增长。
* 对网关执行负载测试，以确保不会为服务引入级联故障。
* 实现弹性设计，使用技术，如舱壁，断路，重试（TODO: 链接到此模式）和超时。
* 如果一个或多个服务调用花费的时间太长，超时和返回部分数据集可能是可以接受的。考虑应用程序将如何处理此场景。
* 使用异步 I/O 确保后端的延迟不会导致应用程序的性能问题。
* 监控请求指标和响应大小。
* 考虑将返回缓存数据作为处理故障的故障转移策略。
* 不要在网关中构建聚合，而是考虑在网关后面放置一个聚合服务。
  请求聚合可能与网关中的其他服务有不同的资源需求，并可能影响网关的路由和卸载功能。

# 何时使用

在以下情况下使用这种模式:

* 客户端需要与多个后端服务通信以执行操作。
* 客户端可能使用具有显著延迟的网络，例如蜂窝网络。

在下列情况下，这种模式可能不适用:

* 您希望减少跨多个操作的客户端和单个服务之间的调用数量。在这种情况下，最好向服务添加一个批处理操作。
* 客户端或应用程序位于后端服务附近，延迟不是一个重要因素。

# 示例

下面的示例说明如何使用 Lua 创建一个简单的网关聚合 NGINX 服务。

```lua
worker_processes  4;

events {
  worker_connections 1024;
}

http {
  server {
    listen 80;

    location = /batch {
      content_by_lua '
        ngx.req.read_body()

        -- read json body content
        local cjson = require "cjson"
        local batch = cjson.decode(ngx.req.get_body_data())["batch"]

        -- create capture_multi table
        local requests = {}
        for i, item in ipairs(batch) do
          table.insert(requests, {item.relative_url, { method = ngx.HTTP_GET}})
        end

        -- execute batch requests in parallel
        local results = {}
        local resps = { ngx.location.capture_multi(requests) }
        for i, res in ipairs(resps) do
          table.insert(results, {status = res.status, body = cjson.decode(res.body), header = res.header})
        end

        ngx.say(cjson.encode({results = results}))
      ';
    }

    location = /service1 {
      default_type application/json;
      echo '{"attr1":"val1"}';
    }

    location = /service2 {
      default_type application/json;
      echo '{"attr2":"val2"}';
    }
  }
}
```