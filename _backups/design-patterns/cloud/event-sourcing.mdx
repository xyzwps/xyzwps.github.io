---
title: 事件溯源
translateFrom: https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing
---


使用仅追加（*append-only*）存储记录发生在数据上的完整操作序列，而非只把当前状态存储在领域中。
存储用作记录系统，也可用于物化领域对象。这可以简化复杂领域中的任务，
避免数据模型和业务领域同步，同时提高性能、可伸缩性和响应性。
它还可以为事务数据提供一致性，并维护完整的审计线索和历史记录，以支持补偿操作。

# 问题背景

大多数应用程序处理数据，典型的方法是应用程序通过在用户处理数据时更新数据来维护数据的当前状态。
例如，在传统的创建、读取、更新和删除(CRUD)模型中，典型的数据流程是从存储中读取数据，
对其进行一些修改，并用新值更新数据的当前状态ーー通常是使用锁定数据的事务。

CRUD 方法有一些局限性:

* CRUD 系统直接针对数据存储执行更新操作，这会降低性能和响应速度，并限制可伸缩性，因为它需要处理开销。
* 在具有许多并发用户的协作域中，数据更新冲突更有可能发生，因为更新操作发生在单个数据项上。
* 除非有一个额外的审计机制，将每个操作的详细信息记录在单独的日志中，否则历史记录将丢失。

# 解决方案

事件溯源模式定义了一种处理由一系列事件驱动的数据操作的方法，每个事件都记录在仅追加存储中。
应用程序代码向事件存储区发送一系列事件，这些事件强制性地描述数据上发生的每个操作，
并将这些操作保存在事件存储区中。每个事件表示对数据的一组更改(例如 AddedItemToOrder)。

事件保存在充当有关数据当前状态的记录系统(权威数据源)的事件存储中。
事件存储通常发布这些事件，以便可以通知使用者并在需要时处理它们。
例如，使用者可以启动将事件中的操作应用于其他系统的任务，或者执行完成操作所需的任何其他相关操作。
注意，生成事件的应用程序代码与订阅事件的系统是解耦的。

事件存储发布的事件的典型用途是在应用程序中的操作更改实体时维护实体的物化视图，并与外部系统集成。
例如，系统可以维护用于填充 UI 部分的所有客户订单的物化视图。
当应用程序添加新订单、添加或删除订单上的项目以及添加运输信息时，
可以处理描述这些更改的事件并用于更新物化视图（TODO: 链接到此模式）。

此外，在任何时候，应用程序都可以读取事件的历史记录，
并通过回放和使用与该实体相关的所有事件来实现实体的当前状态。
这可以在处理请求时根据需要实现域对象，也可以通过计划任务实现，
以便实体的状态可以存储为实体化视图，从而支持表示层。

该图显示了该模式的概述，包括使用事件流的一些选项，
例如创建物化视图、将事件与外部应用程序和系统集成以及重播事件以创建对特定实体当前状态的预测。

![event sourcing overview](/asset/img/event-sourcing-overview.png)

事件采购模式提供了以下优点:

* 事件是不可变的，可以使用仅追加操作来存储。启动事件的用户界面、工作流或流程可以继续，
  处理事件的任务可以在后台运行。再加上事务处理过程中没有争用的事实，
  可以极大地提高应用程序的性能和可伸缩性，特别是对于表示级别或用户界面。
* 事件是描述发生的某些操作的简单对象，以及描述由事件表示的操作所需的任何关联数据。
  事件不直接更新数据存储区。它们只是为了在适当的时候处理而被记录下来。这可以简化实现和管理。
* 事件通常对领域专家有意义，而对象关系不匹配会使复杂的数据库表难以理解。
  表是人工构造，表示系统的当前状态，而不是发生的事件。
* 事件溯源有助于防止并发更新引起冲突，因为它避免了直接更新数据存储中的对象的需求。
  但是，域模型的设计仍然必须保护自己不受可能导致不一致状态的请求的影响。
* 事件的只追加存储提供了一个审计跟踪，可用于监视针对数据存储采取的操作，
  通过随时重播事件将当前状态重新生成物化视图或预测，并协助测试和调试系统。
  此外，使用补偿事件来取消更改的要求提供了被逆转的更改历史记录，如果模型只是存储当前状态，
  就不会出现这种情况。事件列表还可用于分析应用程序性能和检测用户行为趋势，或获取其他有用的业务信息。
* 事件存储引发事件，任务执行响应这些事件的操作。这种任务与事件的分离提供了灵活性和可扩展性。
  任务知道事件的类型和事件数据，但不知道触发事件的操作。此外，多个任务可以处理每个事件。
  这使得与其他只侦听事件存储引发的新事件的服务和系统轻松集成。
  然而，事件溯源事件往往是非常低级的，因此可能需要生成特定的集成事件。

> 事件溯源通常与 CQRS 模式结合在一起，通过执行响应事件的数据管理任务，以及实现来自存储事件的视图。

# 问题与注意事项

在决定如何实现此模式时，请考虑以下几点:

该系统只有在创建具体视图或通过重播事件生成数据预测时才能最终保持一致。
应用程序在处理请求、发布的事件和处理它们的事件的使用者之间向事件存储区添加事件会有一定的延迟。
在此期间，描述对实体进一步更改的新事件可能已经到达事件存储区。

> 有关最终一致性的信息，请参阅<a href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10)">数据一致性入门</a>。

事件存储区是永久的信息源，因此永远不应更新事件数据。
更新实体以撤消更改的唯一方法是向事件存储添加补偿事件。
如果持久化事件的格式(而不是数据)需要更改(可能是在迁移过程中) ，则很难将存储中的现有事件与新版本结合起来。
可能需要迭代所有进行更改的事件，以便它们与新格式兼容，或者添加使用新格式的新事件。
考虑在事件模式的每个版本上使用一个版本标记来维护旧的和新的事件格式。

多线程应用程序和多个应用程序实例可能在事件存储中存储事件。
事件存储中事件的一致性至关重要，影响特定实体的事件顺序(实体发生的更改顺序影响其当前状态)也是如此。
为每个事件添加时间戳可以帮助避免问题。另一种常见的做法是使用增量标识符对请求产生的每个事件进行注释。
如果两个操作试图同时为同一实体添加事件，则事件存储区可以拒绝与现有实体标识符和事件标识符匹配的事件。

没有标准的方法或现有的机制(如 SQL 查询)来读取事件以获取信息。
唯一可以提取的数据是使用事件标识符作为条件的事件流。事件 ID 通常映射到各个实体。
实体的当前状态只能通过针对该实体的原始状态重播与其相关的所有事件来确定。

每个事件流的长度影响管理和更新系统。如果流很大，请考虑以特定的间隔创建快照，例如指定数量的事件。
可以从快照中获取实体的当前状态，也可以通过重播在该时间点之后发生的任何事件来获取。
有关创建数据快照的详细信息，请参[阅主-从属快照复制](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ff650012(v=pandp.10))。

即使事件溯源将数据更新冲突的可能性降到最低，应用程序仍然必须能够处理由于最终一致性和缺乏事务而导致的不一致。
例如，表示库存减少的事件可能在下订单时到达数据存储区，导致需要通过通知客户或创建延迟订单来协调这两个操作。

事件发布可能至少是一次，因此事件的使用者必须是幂等的。如果事件处理多次，则不能重新应用事件中描述的更新。
例如，如果使用者的多个实例维护和聚合一个实体的属性(例如已下订单的总数) ，则在发生已下订单事件时，
只有一个实例必须成功地增加该聚合。虽然这不是事件溯源的一个关键特征，但它是通常的实现决策。

# 何时使用

在以下场景中使用此模式:

* 当您希望在数据中捕获意图、目的或原因时。
  例如，对客户实体的更改可以被捕获为一系列特定的事件类型，如搬家、关闭的帐户或已故。
* 当最小化或完全避免数据更新冲突的发生至关重要时。
* 当您希望记录发生的事件并能够重播它们以恢复系统状态时，请回滚更改，或保留历史记录和审计日志。
  例如，当一个任务涉及多个步骤时，您可能需要执行操作来恢复更新，然后重播一些步骤来将数据恢复到一致的状态。
* 当使用事件是应用程序操作的一个自然特性，并且几乎不需要额外的开发或实现工作。
* 当需要将输入或更新数据的过程与应用这些操作所需的任务分离时。这可能是为了提高 UI 性能，
  或者将事件分发给在事件发生时采取行动的其他侦听器。
  例如，将薪金系统与费用提交网站结合起来，以便网站和薪金系统都能使用事件存储根据网站上的数据更新而引发的事件。
* 当您希望灵活性能够在需求发生变化时更改物化模型和实体数据的格式时，
  或者ーー当与 CQRS 一起使用时ーー需要调整读取模型或公开数据的视图。
* 当与 CQRS 结合使用时，在更新读取模型时，最终一致性是可以接受的，
  或者可以接受事件流中的再水化实体和数据的性能影响。

这种模式在下列情况下可能不适用:

* 小的或简单的域，很少或没有业务逻辑的系统，或者非域系统，这些系统与传统的 CRUD 数据管理机制一起工作得很好。
* 需要对数据视图进行一致性和实时更新的系统。
* 不需要回滚和重播操作的审计跟踪、历史记录和能力的系统。
* 对基础数据进行冲突性更新的发生率非常低的系统。例如，主要添加数据而不是更新数据的系统。

# 示例：

会议管理系统需要跟踪已完成的会议预订数量，以便在潜在与会者试图预订时检查是否还有座位可用。
该系统至少可以通过两种方式存储会议的总预订量:

* 该系统可以将有关预订总数的信息作为一个单独的实体存储在一个保存预订信息的数据库中。
  当预订完成或取消时，系统可以适当地增加或减少这个数字。这种方法在理论上很简单，
  但是如果大量的与会者试图在短时间内预订座位，就会导致可伸缩性问题。
  例如，在预订期结束前的最后一天左右。
* 系统可以将有关预订和取消的信息存储为事件存储中的事件。
  然后，它可以通过重播这些事件来计算可用座位的数量。由于事件的不可变性，这种方法可以更具可伸缩性。
  系统只需要能够从事件存储区读取数据，或者将数据追加到事件存储区。有关预订和取消的事件信息永远不会被修改。

下图说明如何使用事件来源实现会议管理系统的座位预订子系统。

![event sourcing bounded context](/asset/img/event-sourcing-bounded-context.png)

保留两个席位的行动顺序如下:

1. 用户界面发出一个命令，为两名与会者保留座位。该命令由单独的命令处理程序处理。
  一种与用户界面分离的逻辑，负责处理作为命令发布的请求。
1. 通过查询描述预订和取消的活动，构建了一个包含会议所有预订信息的聚合。
   此聚合称为 SeatUtiability，包含在一个域模型中，该模型公开用于查询和修改聚合中的数据的方法。
   > 需要考虑的一些优化包括使用快照(这样您就不需要查询和重播完整的事件列表来获得聚合的当前状态) ，
   > 以及在内存中维护聚合的缓存副本。
1. 命令处理程序调用域模型公开的方法来进行预订。
1. “可用座位数”聚合记录包含预留座位数的事件。下一次总体应用事件时，所有的预订将被用来计算还剩下多少席位。
1. 系统将新事件追加到事件存储区中的事件列表中。

如果用户取消了一个座位，除了命令处理程序发出一个生成一个座位取消事件并将其附加到事件存储区的命令之外，系统遵循类似的过程。

除了提供更大的可伸缩性范围外，使用事件存储还可以提供会议预订和取消的完整历史记录或审计线索。
事件存储区中的事件是准确的记录。
不需要以任何其他方式持久化聚合，因为系统可以轻松地重播事件并将状态恢复到任何时间点。

> 您可以在[介绍事件溯源](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj591559(v=pandp.10))中找到有关此示例的更多信息。

# 参考

- [Microsoft: Event sourcing overview](https://docs.microsoft.com/en-us/dotnet/orleans/grains/event-sourcing/)
- [Microservices: Event Sourcing](https://microservices.io/patterns/data/event-sourcing.html)
- [What Is Event Sourcing?](https://www.event-sourcing.dev/what-is/)
- [An introduction to event sourcing](https://developer.ibm.com/articles/event-sourcing-introduction/)
- [What is Event Sourcing?](https://www.eventstore.com/blog/what-is-event-sourcing)
- [Martin Fowler: Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)
- [Introduction to Event Sourcing - Self Paced Kit](https://event-driven.io/en/introduction_to_event_sourcing/)
- [Event Sourcing and CQRS](https://www.eventstore.com/blog/event-sourcing-and-cqrs)
- [AxonIQ: Event Sourcing](https://docs.axoniq.io/reference-guide/architecture-overview/event-sourcing)
- [When not to use Event Sourcing?](https://event-driven.io/en/when_not_to_use_event_sourcing/)
- [Akka: Event Sourcing](https://doc.akka.io/docs/akka/current/typed/persistence.html)
- [AWS: Event sourcing pattern](https://docs.aws.amazon.com/prescriptive-guidance/latest/modernization-data-persistence/service-per-team.html)
- [Event Sourcing vs. Event Streaming](https://developer.confluent.io/learn-kafka/event-sourcing/event-sourcing-vs-event-streaming/)