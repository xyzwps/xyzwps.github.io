# 思路二：基于 `forEach`

原文见：[一种新的流：为Java加入生成器(Generator)特性](https://mp.weixin.qq.com/s/v-HMKBWxtz1iakxFL09PDw)

下面以我的方式来简单叙述一遍。

## 核心接口

整个故事开始于这样一个接口：

```java
// 为了和思路一种的 `Sequence` 做区分，这里取名叫 `Traversable`
public interface Traversable<T> {
    void forEach(Consumer<? super T> consumer);
}
```

## 创建 `Traversable`

为了能够开始，我们需要几个工厂方法：

```java
public interface Traversable<T> {

    static <T> Traversable<T> empty() {
        return Functions::consumeNothing;
    }

    static <T> Traversable<T> from(Iterable<T> list) {
        return list == null ? Traversable.empty() : list::forEach;
    }

    @SafeVarargs
    static <T> Traversable<T> just(T... args) {
        return tConsumer -> {
            for (T t : args) {
                tConsumer.accept(t);
            }
        };
    }
}
```

无限序列也很简单：

```java
@SuppressWarnings("InfiniteLoopStatement")
static Traversable<Long> infinite(long start) {
    var counter = new LongCounter(start);
    return consumer -> {
        while (true) {
            consumer.accept(counter.getAndIncr());
        }
    };
}
```

## 操作 `Traversable`

`map` 和 `filter` 非常简单：

```java
default <R> Traversable<R> map(Function<T, R> mapFn) {
    Objects.requireNonNull(mapFn);
    return rConsumer -> this.forEach(t -> rConsumer.accept(mapFn.apply(t)));
}

default Traversable<T> filter(Predicate<T> predicate) {
    Objects.requireNonNull(predicate);
    return tConsumer -> this.forEach(t -> {
        if (predicate.test(t)) {
            tConsumer.accept(t);
        }
    });
}
```

`take` 较为麻烦，因为我们希望在 take 到足够的元素后，就终止继续 take。
这里要中断，我们就只能抛个异常了，即：抛完异常就正常终止。

```java
default Traversable<T> take(final int n) {
    if (n < 1) throw new IllegalArgumentException();


    return StopException.stop(tConsumer -> {
        Counter counter = new Counter(0);
        this.forEach(t -> {
            if (counter.getAndIncr() < n) {
                tConsumer.accept(t);
            }

            if (counter.get() >= n) {
                throw StopException.INSTANCE;
            }
        });
    });
}
```

注意，我们只是借用 Java 的异常机制来中断后续操作，而不是真的在乎这个异常，需要在外面捕获。
我们甚至不关心这个异常的 stackTrace。所以 `StopException` 张这个样子：

```java
class StopException extends RuntimeException {

    private StopException() { super("", null, false, false); }

    static final StopException INSTANCE = new StopException();

    static <T> Traversable<T> stop(Traversable<T> traversable) {
        return tConsumer -> {
            try {
                traversable.forEach(tConsumer);
            } catch (StopException ignored) { }
        };
    }

    static void stop(Runnable runnable) {
        try {
            runnable.run();
        } catch (StopException ignored) { }
    }
}
```

下面我们写一段代码测试一下：

```java
static void main(String[] args) {
    var t = infinite(0)
            .filter(i -> {
                System.out.printf("=> filter: %d > 1\n", i);
                return i > 1;
            })
            .map(i -> {
                System.out.printf("=> map: %d + 4 = %d\n", i, i + 4);
                return i + 4;
            })
            .take(2);
    System.out.println("============");
    t.forEach(it -> System.out.printf("=> forEach %d \n", it));
    System.out.println("============");
}
```

输出：

```
============
=> filter: 0 > 1
=> filter: 1 > 1
=> filter: 2 > 1
=> map: 2 + 4 = 6
=> forEach 6
=> filter: 3 > 1
=> map: 3 + 4 = 7
=> forEach 7
============
```

完美！

## 其他操作

### `flatMap`

```java
default <R> Traversable<R> flatMap(Function<T, Traversable<R>> flatMapFn) {
    return consumer -> this.forEach(t -> {
        Traversable<R> rt = flatMapFn.apply(t);
        if (rt != null) {
            rt.forEach(consumer);
        }
    });
}
```

### `reduce`

```java
default <R> R reduce(R initValue, BiFunction<R, T, R> reducer) {
    var rHolder = new ObjectHolder<>(initValue);
    this.forEach(t -> rHolder.set(reducer.apply(rHolder.value(), t)));
    return rHolder.value();
}
```

### `iterator`

用这个接口实现 `iterator()` 也可以，但是返回的 `Iterator` 它不 lazy 😂。
主要原因在于，这个接口没办法按顺序一次只取一个元素。因为代码也很简单，所以就不列出来了。

其他操作也不列出来了。
