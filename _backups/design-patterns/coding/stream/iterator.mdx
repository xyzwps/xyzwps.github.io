# 思路一：基于 `Iterator`

我最开始的想法就是 `Iterator` 实现。这也是一个装饰器模式（_decorator pattern_）示例。

## 核心类

整个故事开始于这样一个类：

```java
public class ChainIterable<T> implements Iterable<T> {

    private final Iterable<T> iterable;

    public ChainIterable(Iterable<T> iterable) {
        this.iterable = iterable == null ? EmptyIterator::create : iterable;
    }

    @Override
    public Iterator<T> iterator() {
        return iterable.iterator();
    }
}
```

## 基本操作

### `map`

`map` 实际上是一个 `Iterator`。代码非常简单，就是有点啰嗦:

```java
public class MapIterator<T, R> implements Iterator<R> {

    private final Function<T, R> mapper;
    private final Iterator<T> from;

    public MapIterator(Iterator<T> from, Function<T, R> mapper) {
        this.from = Objects.requireNonNull(from);
        this.mapper = Objects.requireNonNull(mapper);
    }

    @Override
    public boolean hasNext() {
        return from.hasNext();
    }

    @Override
    public R next() {
        return mapper.apply(from.next());
    }
}
```

我们需要把 `map` 方法定义在 `ChainIterable` 中：

```java
public class ChainIterable<T> implements Iterable<T> {
    // ...

    public <R> ChainIterable<R> map(Function<T, R> mapper) {
        Objects.requireNonNull(mapper);
        return this.chain(itr -> new MapIterator<>(itr, mapper));
    }

    private <R> ChainIterable<R> chain(Function<Iterator<T>, Iterator<R>> fn) {
        return new ChainIterable<>(() -> fn.apply(this.iterable.iterator()));
    }
}
```

这里有个 `chain` 方法把前后两个 `Iterator` 串起来。

### `fitler`

`fitler` 实际上也是一个 `Iterator`。不过因为要判断 `hasNext`，要先找到 `next`，所以代码稍微复杂一点：

```java
public class FilterIterator<T> implements Iterator<T> {

    private final Predicate<T> predicate;
    private final Iterator<T> from;

    public FilterIterator(Iterator<T> from, Predicate<T> predicate) {
        this.from = Objects.requireNonNull(from);
        this.predicate = Objects.requireNonNull(predicate);
    }

    private ObjectHolder<T> next = null;

    private void tryFindNext() {
        if (next != null) return;

        while (from.hasNext()) {
            var next = from.next();
            if (predicate.test(next)) {
                this.next = new ObjectHolder<>(next);
                return;
            }
        }
    }

    @Override
    public boolean hasNext() {
        this.tryFindNext();
        return next != null;
    }

    @Override
    public T next() {
        this.tryFindNext();
        if (this.next == null) {
            throw new NoSuchElementException();
        }

        var value = this.next.value();
        this.next = null;
        return value;
    }
}
```

把它搞到 `ChainIterable` 中：

```java
public ChainIterable<T> filter(Predicate<T> predicate) {
    Objects.requireNonNull(predicate);
    return this.chain(itr -> new FilterIterator<>(itr, predicate));
}
```

### `take`

`take` 也是一个 `Iterator`。不过它需要记录当前已经取了多少个元素，所以需要一个计数器：

```java
public class TakeIterator<T> implements Iterator<T> {
    private final int n;
    private final Iterator<T> from;
    private int current = 0;

    public TakeIterator(Iterator<T> from, int n) {
        this.from = Objects.requireNonNull(from);
        this.n = n;
    }


    @Override
    public boolean hasNext() {
        return current < n && from.hasNext();
    }

    @Override
    public T next() {
        if (this.hasNext()) {
            this.current++;
            return from.next();
        } else {
            throw new NoSuchElementException();
        }
    }
}
```

把它搞到 `ChainIterable` 中：

```java
public ChainIterable<T> take(int n) {
    return this.chain(itr -> new TakeIterator<>(itr, n));
}
```

### 测试

```java
public static void main(String[] args) {
    var t = infinite(0)
            .filter(i -> {
                System.out.printf("=> filter: %d > 1\n", i);
                return i > 1;
            })
            .map(i -> {
                System.out.printf("=> map: %d + 4 = %d\n", i, i + 4);
                return i + 4;
            })
            .take(2);
    System.out.println("============");
    t.forEach(it -> System.out.printf("=> forEach %d \n", it));
    System.out.println("============");
}
```

输出如下：

```java
============
=> filter: 0 > 1
=> filter: 1 > 1
=> filter: 2 > 1
=> map: 2 + 4 = 6
=> forEach 6
=> filter: 3 > 1
=> map: 3 + 4 = 7
=> forEach 7
============
```

完美！

因为 `Iterator` 接口中，判断是否有下一个元素和获取下一个元素这两个操作是分开的，所以代码变得极为啰嗦。
其他操作也是一样啰嗦，不再列出。