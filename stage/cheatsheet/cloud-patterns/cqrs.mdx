---
layout: ../../../layouts/MdxLayout.astro
title: CQRS pattern
parent:
  name: 返回上级
  path: /cheatsheet/cloud-patterns/
translateFrom:
  url: https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs
  title: CQRS pattern - Azure Architecture Center
---

CQRS（*Command and Query Responsibility Segregation*）是一种分离对数据存储读写的模式。
在应用程序中实现 CQRS 可以极大地提高其性能、可扩展性和安全性。
迁移到 CQRS 所创造的灵活性允许系统随着时间的推移更好地发展，并防止更新命令在领域层引起合并冲突。

## 问题上下文

在传统架构中，查询和更新数据使用相同的数据模型。对于简单的 CRUD 操作来说，这很简单，工作得也很好。
然而，在更复杂的应用程序中，这种方法可能会变得笨拙。
例如，在读数据的一侧，应用程序可能执行许多不同的查询，返回具有不同形状的数据传输对象（DTO）。对象映射可能会变得复杂。
在写数据的一侧，模型可能会实现复杂的验证和业务逻辑。因此，您最终可能会得到一个做太多事情的过于复杂的模型。

读和写工作负载通常是不对称的，具有非常不同的性能和规模要求。

- 数据的读写表示之间经常存在不匹配，例如必须正确更新的附加列或属性，即使它们不是操作的一部分。
- 当对同一组数据并行执行操作时，可能会发生数据争用。
- 由于数据存储和数据访问层的负载以及检索信息所需的查询的复杂性，传统方法可能会对性能产生负面影响。
- 管理安全性和权限可能会变得复杂，因为每个实体都要执行读取和写入操作，这可能会在错误的上下文中公开数据。

## 解决方案

CQRS 将读写分离到不同的模型中，使用**命令**（*command*）更新数据，使用**查询**（*query*）读取数据。

- 命令应该是基于任务的，而不是以数据为中心的。（“预订酒店房间”，而不是“将预订状态设置为预订”）。
  这可能需要对用户交互风格进行一些相应的更改。另一部分是考虑修改处理这些命令的业务逻辑以更频繁地成功。
  支持这一点的一种技术是甚至在发送命令之前在客户端上运行一些验证规则，可能会禁用按钮，并在UI上解释原因（“没有房间了”）。
  通过这种方式，服务器端命令失败的原因可以缩小到竞争条件（两个用户试图预订最后一个房间），
  甚至有时可以通过更多的数据和逻辑来解决这些问题（将客人放在等待列表中）。
- 命令可以放置在队列中进行异步处理，而不是同步处理。
- 查询永远不会修改数据库。查询返回不封装任何领域知识的DTO。

拥有单独的查询和更新模型可以简化设计和实现。
然而，一个缺点是不能使用脚手架机制（如O/RM工具）从数据库模式自动生成CQRS代码。
但是，您将能够在生成的代码之上构建自定义

为了获得更大的隔离，您可以在物理上将读取数据与写入数据分开。
在这种情况下，读取数据库可以使用自己的针对查询优化的数据模式。
例如，它可以存储数据的物化视图，以避免复杂的连接或复杂的O/RM映射。
它甚至可能使用不同类型的数据存储。
例如，写数据库可能是关系数据库，而读数据库是文档数据库。

如果使用读写分离的数据库，它们必须保持同步。
通常，这是通过让写入模型在更新数据库时发布事件来实现的。
有关使用事件的详细信息，请参阅事件驱动的体系结构样式。 TODO:
由于消息代理和数据库通常无法登记到单个分布式事务中，因此在更新数据库和发布事件时保证一致性可能存在挑战。
有关详细信息，请参阅幂等消息处理指南。TODO:

读取存储可以是写入存储的只读副本，或者读取和写入存储可以具有完全不同的结构。
使用多个只读副本可以提高查询性能，尤其是在只读副本位于应用程序实例附近的分布式场景中。

读写存储的分离还允许适当地扩展每个存储以匹配负载。例如，读存储通常会遇到比写存储高得多的负载。

CQRS的一些实现使用事件源模式。TODO:
使用此模式，应用程序状态存储为一系列事件。
每个事件代表对数据的一组更改。
当前状态是通过重播事件来构建的。
在CQRS上下文中，事件源的一个好处是可以使用相同的事件来通知其他组件——特别是通知读取模型。
读取模型使用事件来创建当前状态的快照，这对于查询来说更有效。
但是，事件源增加了设计的复杂性。

CQRS 的好处包括：

- **独立扩展**：CQRS允许读取和写入工作负载独立扩展，并可能导致更少的锁争用。
- **优化的数据格式**：读端可以使用针对查询优化的格式，而写端使用针对更新优化的格式。
- **安全**。更容易确保只有正确的域实体对数据执行写入。
- **关注点分离**。分离读写端可以产生更易于维护和灵活的模型。大多数复杂的业务逻辑都进入了写模型。读模型可以相对简单。
- **更简单的查询**。通过在读取数据库中存储物化视图，应用程序可以在查询时避免复杂的连接。

## 实现考量

实现此模式会遇到一些挑战：

- **复杂性**：CQRS的基本思想很简单。但它可能会导致更复杂的应用程序设计，尤其是如果它们包含事件源模式。
- **消息传递**：虽然CQRS不需要消息传递，但通常使用消息传递来处理命令和发布更新事件。
  在这种情况下，应用程序必须处理消息失败或重复消息。
  有关处理具有不同优先级的命令，请参阅优先级队列指南。 TODO:
- **最终一致性**：如果将读数据库和写数据库分开，则读数据可能是陈旧的。
  必须更新读模型存储以反映对写模型存储的更改，并且很难检测用户何时根据陈旧的读数据发出请求。

## 何时使用

以下场景可以考虑 CQRS：

- 许多用户并行访问相同数据的协作域。CQRS允许您定义具有足够颗粒度的命令，以最小化域级别的合并冲突，并且确实出现的冲突可以通过命令合并。

- 在基于任务的用户界面上，通过一系列步骤或复杂的域模型引导用户完成复杂的流程。
  写入模型具有完整的命令处理栈，包括业务逻辑、输入验证和业务验证。
  写入模型可以将一组关联对象视为数据更改的单个单元（DDD术语中的聚合），并确保这些对象始终处于一致状态。
  读取模型没有业务逻辑或验证堆栈，只是返回一个DTO以供视图模型使用。读取模型最终与写入模型保持一致。

- 数据读取性能必须与数据写入性能分开微调的场景，尤其是当读取次数远大于写入次数时。
  在这种情况下，您可以横向扩展读取模型，但只在少数实例上运行写入模型。
  少量写入模型实例也有助于最大限度地减少合并冲突的发生。

- 一个开发团队可以专注于作为写入模型一部分的复杂域模型，而另一个团队可以专注于读取模型和用户界面的场景。

- 系统预计会随着时间的推移而发展并且可能包含模型的多个版本，或者业务规则定期更改的场景。

- 与其他系统集成，尤其是与事件源结合使用，其中一个子系统的临时故障不应该影响其他子系统的可用性。

以下场景不适用：

- 领域或业务规则很简单。
- 一个简单的CRUD风格的用户交互界面和数据访问操作就足够了。

考虑将CQRS应用于系统中最有价值的有限部分。

## Event Sourcing and CQRS pattern

CQRS模式通常与事件源模式一起使用。
基于CQRS的系统使用读写分离的数据模型，每个模型都针对相关任务量身定制，并且通常位于物理上独立的存储中。
当与事件源模式一起使用时，事件的存储是写入模型，并且是信息的官方来源。
基于CQRS的系统的读取模型提供数据的物化视图，通常作为高度非规范化的视图。
这些视图是根据应用程序的界面和显示要求量身定制的，这有助于最大限度地提高显示和查询性能。

使用事件流作为写存储，而不是某个时间点的实际数据，可以避免单个聚合上的更新冲突，并最大限度地提高性能和可伸缩性。
事件可用于异步生成用于填充读取存储的数据的物化视图。

因为事件存储是信息的官方来源，所以可以删除物化视图并重放所有过去的事件，
以便在系统发展或读取模型必须更改时创建当前状态的新表示。物化视图实际上是数据的持久只读缓存。

将CQRS与事件源模式结合使用时，请考虑以下几点：

- 与任何写存储和读存储分开的系统一样，基于这种模式的系统最终才是一致的。在生成事件和更新数据存储之间会有一些延迟。

- 该模式增加了复杂性，因为必须创建代码来启动和处理事件，并组装或更新查询或读取模型所需的适当视图或对象。
  与事件源模式一起使用时，CQRS模式的复杂性会使成功的实现更加困难，并且需要不同的系统设计方法。
  然而，事件源可以更容易地对域进行建模，并且更容易重建视图或创建新视图，因为保留了数据更改的意图。

- 通过重放和处理特定实体或实体集合的事件来生成用于读取模型或数据投影的物化视图可能需要大量的流转时长和资源使用。
  如果需要在长时间内求和或分析值，尤其如此，因为可能需要检查所有相关事件。
  通过按预定时间间隔实现数据快照来解决这个问题，例如已发生的特定操作的总数，或者实体的当前状态。

## 参考

- [CQRS - Martin Fowler](https://martinfowler.com/bliki/CQRS.html)
- [What do you mean by “Event-Driven”? - Martin Fowler](https://martinfowler.com/articles/201701-event-driven.html)