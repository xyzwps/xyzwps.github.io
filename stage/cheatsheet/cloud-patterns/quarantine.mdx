---
layout: ../../../layouts/MdxLayout.astro
title: Quarantine pattern
parent:
  name: 返回上级
  path: /cheatsheet/cloud-patterns/
translateFrom:
  url: https://learn.microsoft.com/en-us/azure/architecture/patterns/quarantine
  title: Quarantine pattern - Azure Architecture Center
---

TODO: 翻译很奇怪

只有在经过明确定义的流程验证并标记为可安全使用时，才在供应链中使用第三方软件工件。
此模式是开发过程的操作[边车](/cheatsheet/cloud-patterns/sidecar)。
此模式的消费者调用此流程来验证和阻止可能引入安全漏洞的软件的使用。

## 问题上下文

云解决方案通常依赖于从外部来源获得的第三方软件。
开源二进制文件、公共容器映像、供应商操作系统映像是这些类型工件的一些示例。
所有这些外部工件都必须被视为不受信任的。

在典型的工作流中，从解决方案范围之外的存储中检索工件，然后将其集成到部署管道中。
这种方法存在一些潜在问题。源可能不受信任，工件可能包含漏洞，或者它可能不适合开发人员环境的其他方式。

如果不解决这些问题，解决方案的数据完整性和机密性保证可能会受到损害，或者由于与其他组件不兼容而导致不稳定。

通过向每个工件添加检查，可以避免其中一些安全问题。

## 解决方案

在将软件引入工作负载之前，有一个验证软件安全性的流程。
在此过程中，每个工件都经过彻底的操作严格性，根据特定条件对其进行验证。
只有在工件满足这些条件后，该流程才会将其标记为受信任。

> 隔离过程是一种安全措施，它由在工件被使用之前使用的一系列检查点组成。
> 这些安全检查点确保工件从不受信任的状态转换到受信任的状态。

需要注意的是，隔离过程不会改变工件的组成。
该过程独立于软件开发周期，并由消费者根据需要调用。
作为工件的消费者，阻止工件的使用，直到它们通过隔离。

以下是典型的隔离工作流程：

![](https://learn.microsoft.com/en-us/azure/architecture/patterns/_images/quarantine.png)

1. 消费者发出他们的意图信号，指定工件的输入来源，并阻止其使用。

2. 隔离进程验证请求的来源并从指定的存储中获取工件。

3. 自定义验证过程作为隔离的一部分执行，其中包括验证输入约束并根据已建立的标准检查属性、源和类型。

   其中一些安全检查可以是对每个提交的工件进行漏洞扫描、恶意软件检测等。

   实际检查取决于工件的类型。例如，评估操作系统映像与评估NuGet包不同。

4. 如果验证过程成功，则工件将发布在带有清晰注释的安全存储中。否则，消费者仍然无法使用它。

   发布过程可以包括显示验证证明和每个检查的重要性的累积报告。
   在报告中包括过期时间，超过过期时间，报告将无效，工件将被视为不安全。

5. 该过程通过向带有状态信息的事件发出信号并伴随报告来标志隔离的结束。

   根据这些信息，消费者可以选择采取行动来使用受信任的工件。这些操作超出了隔离模式的范围。

## 注意事项

- 作为使用第三方工件的团队，请确保它是从受信任的来源获得的。
  您的选择必须与从第三方供应商处采购的工件的organization-approved标准保持一致。
  供应商必须能够满足您的工作负载（和您的组织）的安全要求。
  例如，确保供应商的负责任披露计划符合您组织的安全要求。

- 在存储受信任和不受信任工件的资源之间创建分段。使用身份和网络控制来限制对授权用户的访问。

- 有一个可靠的方法来调用隔离过程。确保工件在被标记为受信任之前不会被无意中使用。
  信令应该是自动化的。例如，与在工件被引入开发人员环境时通知责任方、提交对GitHub存储库的更改、将映像添加到私有注册表等相关的任务。

- 实施隔离模式的另一种选择是将其外包。有专门从事公共资产验证的隔离从业者作为他们的商业模式。
  评估实施模式与外包责任的财务和运营成本。如果您的安全需求需要更多控制，建议实施您自己的流程。

- 自动化工件摄取过程以及发布工件的过程。因为验证任务可能需要时间，所以自动化过程必须能够持续到所有任务完成。

- 该模式用作第一次机会瞬间验证。成功通过隔离并不能确保工件无限期地保持可信。
  工件必须继续接受持续扫描、管道验证和其他常规安全检查，作为推广发布之前的最后机会验证。

- 该模式可以由组织的中心团队或单个工作负载团队来实现。如果隔离过程有许多实例或变体，这些操作应该由组织标准化和集中。
  在这种情况下，工作负载团队共享流程并从卸载流程管理中受益。

## 何时使用

以下场景可以使用此模式：

- 工作负载集成了在工作负载团队范围之外开发的工件。常见示例包括：

  * 来自公共注册表的开放容器计划（OCI）工件，例如DockerHub、GitHub容器注册表、Microsoft容器注册表

  * 来自公共来源的软件库或包，例如NuGet Gallery、Python Package Index、Apache Maven存储库

  * 外部Infrastructure-as-Code（IaC）包，例如Terraform模块、Community Chef Cookbook、Azure验证模块

  * 供应商提供的操作系统映像

- 工作负载团队认为工件是一个值得减轻的风险。团队了解集成受损工件的负面后果以及隔离在确保可信环境中的价值。

- 团队对应该应用于一种工件的验证规则有清晰和共同的理解。如果没有共识，模式可能不会有效。

  例如，如果每次将OS映像引入隔离区时应用一组不同的验证检查，则OS映像的整个验证过程将变得不一致。


在以下情况下，此模式可能没有用：

- 软件工件由工作负载团队或受信任的合作伙伴团队创建。

- 不验证工件的风险比构建和维护隔离过程的成本要低。
