---
layout: ../../../layouts/MdxLayout.astro
title: 断路器模式
parent:
  name: 返回上级
  path: /cheatsheet/cloud-patterns/
translateFrom:
  url: https://learn.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker
  title: Circuit Breaker pattern - Azure Architecture Center
---

在连接远程服务时，如果远程服务不可用了，而且还不知道需要多久它才能恢复，那么就需要针对这种情况做处理。
这会提升应用的稳定性和弹性。

## 问题上下文

在分布式环境中，应用程序在调用远程服务时，可能会遇到一些短暂的错误，比如网络连接变慢、超时、使用超过限制，或者远程服务短暂不可用等等。
这种错误可能在一小段时间后就会恢复。一个健壮的云应用，应该预先对它们做一些处理，比如[重试](/cheatsheet/cloud-patterns/retry)。

不过，也有些情况，这些远程服务相关错误无法快速恢复。这种错误可能是网络故障，甚至远程服务宕机完全不可用。
这种情况下，应用不断重试可能就没啥意义了，因为重试了也还是失败。
此时，应用程序应该快速地接受操作已经失败的现状，并处理这些错误。

此外，如果一个应用非常忙，系统一部分的失败可能会导致更多的级联失败（雪崩）。
比如，给一个调用远程服务的操作配置一个超时时间，如果超时，就返回一个错误信息。
如果这个操作有很多并发，它们就可能会被阻塞，直到超时。
这些被阻塞的请求，可能持有很多关键系统资源，比如内存、线程、数据库连接等等。
最终这些连接被耗尽，进而导致系统中其他使用这些资源的部分也发生错误。
这种情况下，最好是操作立即失败，只在可能成功的情况下才去尝试调用服务。
设置一个短一点的超时时间可以解决这个问题，但是超时时间也不能太短，要保证大多数情况下操作都能成功。

## 解决方案

断路器（*Circuit Breaker*）模式可以避免应用重复尝试一个可能失败的操作。
它允许操作在失败时继续，而不是一直等，等到故障恢复。
这个模式还能够使应用检测远程服务的相关故障是否已经解决。
如果问题已经解决，应用可以继续去调用那个操作。

> 断路器模式和重试模式的目标不同。重试模式允许应用去尝试一个操作，因为预期它会成功。
> 断路器模式要求应用避免执行一个操作，因为预期它会失败。
> 应用程序可以把这两个模式结合在一起，对一个断路器做重试。
> 这样的话，重试逻辑应该对断路器返回的错误敏感，如果断路器说这个错误暂时不可恢复，重试逻辑就应该终止。

断路器用作那种可能会失败的操作的代理。
这个代理应该监视最近发生的错数量，用这个信息来决定操作是否应该继续，还是简单地立刻返回错误。

这个代理可以用一个状态机来实现。这个状态机模仿了电路断路器的功能，它有以下状态：

* **关闭**（*Closed*）：此时允许应用直接调用远程服务。代理维护一个计数器，用来记录最近一段时间内调用失败的次数。
  如果操作失败，代理会将计数器加一。当计数器在给定的时间内达到或者超过阈值时，代理会进入**开启**状态。
  这时计数器会开始倒计时，倒计时结束时，代理会进入**半开**状态。

  > 倒计时的目的是，给系统留一段时间来修复问题，在修复完成前，别再尝试执行已经失败的操作了。

* **开启**（*Open*）：此时不允许应用直接调用远程服务，而是直接返回一个错误。

* **半开**（*Half-open*）：此时允许应用直接调用远程服务，但是只允许的次数有限。
  如果调用都成功了，就认为远程服务恢复了，代理会进入**关闭**状态，失败计数器也会被重置。
  如果有调用失败了，断路器就认为故障尚未恢复，代理会进入**开启**状态，重启倒计时，当然倒计时的时间可能会更长一点。

  > **半开**状态主要是用于避免远程服务在恢复的过程中，被突然进入的大量请求冲垮。
  > 在远程服务恢复的过程中，它可能只能支撑有限的请求进入，直到完全恢复为止。

断路器模式为系统从故障中恢复的过程中提供了稳定性，也最小化了对性能的影响。
它通过快速拒绝可能失败的操作，来维持系统的响应时间。
如果断路器在状态变化时发送一个状态变化事件，那么，就可以监视系统中被断路器保护的那部分的状态，
或者在断路器开启时，向系统管理员报警。

这个模式是可配置的，可以根据可能出现的错误类型进行调整。
比如，你可以用一个时长不断增长的倒计时，开始的时候，开启状态下倒计时只有几秒钟，如果一直未从故障中恢复，
倒计时时长会增加到几分钟这样。断路器开启时，可以返回一个错误，也可以返回一个有意义的默认值。

## 实现考量

在实现断路器模式时，你应该考虑如下几点：

**异常处理**。应用在通过断路器调用服务时，需要处理异常。处理异常的方式应该根据场景来决定。比如：
应用可以短暂地对功能降级，去调用一个备选的操作，或者使用默认值，或者向用户返回错误要求用户稍后重试。

**异常类型**。一个请求可能因为很多种原因失败，其中一些可能比其他原因更严重。比如，
一个请求失败的原因可能是远程服务故障，需要几分钟去恢复，也可能时因为远程服务瞬时超载，导致请求超时。
断路器应该能够检查错误类型，并依据错误出现的原因来调整策略。比如，服务完全不可用导致的错误需要的计数器阈值，
应该比超时导致的错误需要的计数器阈值要小。

**日志**。断路器应该用日志记录所有的失败请求（成功的也可以记），以允许管理员来监视操作状态。

**可恢复性**。根据要保护的操作的恢复能力，断路器的配置也应该做相应调整。
比如，如果断路器开启状态的时间间过长，就有可能出现远程服务已恢复，但是断路器仍然返回错误的情况。
同样，如果断路器从打开状态切换到半打开状态太快，它可能会波动，并增加应用程序的响应时间。

**测试失败的操作**。在开启状态下，断路器可以周期性地去 ping 远程服务，而不是用倒计时，来决定何时把状态切换到半开状态。
这个 ping 可以是之前失败的操作，也可以是远程服务提供的特殊操作。

**手动覆盖**。如果系统从故障恢复的时长变化很大，有长有短，那么可以考虑给管理员，
提供一个手动关闭断路器（并重置失败计数器）的方式。类似地，如果断路器保护的资源暂时不可用，
管理员要有能力打开断路器。

**并发**。同一个断路器可以被应用的多个并发实例访问。实现这个功能，不应该阻止并发请求，或者为每次操作增加过多开销。

**资源差异**。如果为一类资源使用一个断路器，应当小心，因为底层可能会有不同的独立提供者。
比如，一个数据存储有多个分片，其中一些分片完全可用的同时，其他分片出现了短暂的问题。
这种场景下，如果把错误合并了，一部分分片的错误可能会导致整个数据存储看起来不可用。

**加速断路**。有时，一个错误就能够提供足够的信息，使断路器能够决定立刻开启，并保持一小段时间的开启状态。
比如，一个来自共享资源的错误信息显示，暂时不要重试了，等几分钟再试。

> 一个服务在客户端太猛的时候返回 HTTP 429（Too Many Requests），或者在不可用时返回 HTTP 503（Service Unavailable）。
> 这种响应可能包含足够的额外信息，比如预期的等待时间。

**重放错误请求**。在断路器开启时，不是简单的返回错误，而是要求断路器记录错误请求到日志，安排这些请求在远程服务可用时重放。

**外部服务的不适当超时**。如果外部服务有较长的超时时间，断路器可能无法保护应用。如果超时时间太长，
执行断路器的线程可能会被失败的操作阻塞。如果有大量的请求进来，就会导致大量的线程被阻塞，这个过程中可能会影响其他请求。

## 何时使用

使用场景：

* 调用远程服务失败可能性很大时，使用此模式避免应用尝试调用远程服务。

不推荐的场景：

* 处理应用程序的本地私有资源，比如内存中的数据结构。这种环境下，使用断路器会增加性能开销。
* 作为应用中业务逻辑异常处理的替代方案。