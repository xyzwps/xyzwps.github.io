---
title: CQRS
translateFrom: https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs
---

CQRS 是指**命令和查询责任分离**（*Command and Query Responsibility Segregation*），
这是一种分离数据存储的读取和更新操作的模式。
在应用程序中实现 CQRS 可以最大限度地提高其性能、可伸缩性和安全性。
迁移到 CQRS 所创建的灵活性允许系统随着时间更好地发展，并防止更新命令在域级别引起合并冲突。

# 问题背景

在传统架构中，使用相同的数据模型查询和更新数据库。
这很简单，适用于基本 CRUD 操作。
然而，在更复杂的应用程序中，这种方法可能会变得笨拙。
例如，在读方面，应用程序可能执行许多不同的查询，返回具有不同形状的数据传输对象(DTO)。
对象映射可能变得复杂。
在写方面，模型可以实现复杂的验证和业务逻辑。
因此，您最终可能会得到一个过于复杂的模型，而这个模型做得太多了。

读写工作负载通常是不对称的，具有非常不同的性能和规模要求。

![传统 CRUD](/asset/img/command-and-query-responsibility-segregation-cqrs-tradition-crud.png)

* 数据的读写表示常常不匹配，例如必须正确更新的附加列或属性，即使这些属性不是操作的一部分。
* 当对同一组数据并行执行操作时，可能会发生数据争用。
* 由于数据存储和数据访问层的负载以及检索信息所需的查询的复杂性，传统的方法可能会对性能产生负面影响。
* 管理安全性和权限可能会变得很复杂，因为每个实体都受制于读和写操作，这可能会在错误的上下文中公开数据。

# 解决方案

CQRS 将读写分离到不同的模型中，使用命令更新数据，查询读取数据。

* 命令应该是基于任务的，而不是以数据为中心的。
* 命令可以放在队列上进行异步处理，而不是同步处理。
* 查询从不修改数据库。查询返回一个不封装任何领域知识的 DTO。

这样模型就可以被隔离开了，如下图所示，尽管这不是绝对需求。

![简单 CQRS](/asset/img/command-and-query-responsibility-segregation-cqrs-basic.png)

使用单独的查询和更新模型简化了设计和实现。
然而，一个缺点是 CQRS 代码不能使用 O/RM 工具等脚手架机制从数据库模式自动生成。

为了实现更好的隔离，可以在物理上将读数据与写数据分开。
在这种情况下，read 数据库可以使用自己的数据模式，该模式针对查询进行了优化。
例如，它可以存储数据的物化视图（TODO: 链接到这个模式），以避免复杂的连接或复杂的 O/RM 映射。
它甚至可能使用不同类型的数据存储。例如，写数据库可能是关系数据库，而读数据库是文档数据库。

如果使用单独的读写数据库，则必须保持它们的同步。通常，这是通过让写模型在更新数据库时发布事件来实现的。
有关使用事件的更多信息，请参见[事件驱动架构风格](https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/event-driven)。
更新数据库和发布事件必须在单个事务中进行。

![CQRS 存储分离](/asset/img/command-and-query-responsibility-segregation-cqrs-separate-stores.png)

读存储区可以是写存储区的只读副本，也可以具有完全不同的结构。
使用多个只读副本可以提高查询性能，特别是在只读副本位于应用程序实例附近的分布式场景中。

读和写存储的分离还允许适当地缩放每个存储以匹配负载。例如，读存储通常会遇到比写存储高得多的负载。

CQRS 的一些实现使用事件源模式（TODO: 链接到此模式）。使用此模式，应用程序状态被存储为一系列事件。
每个事件表示对数据的一组更改。通过重播事件构造当前状态。在 CQRS 上下文中，
事件采购的一个好处是可以使用相同的事件通知其他组件ーー特别是通知读取模型。
读取模型使用事件创建当前状态的快照，这对于查询更有效。但是，事件源增加了设计的复杂性。

CQRS 的好处包括：

* **独立伸缩**。 CQRS 允许读写工作负载独立伸缩，并且可能导致更少的锁争用。
* **优化的数据模式**。读方可以使用针对查询优化的架构，而写方使用针对更新优化的架构。
* **安全**。更容易确保只有正确的域实体对数据执行写操作。
* **关注点分离**。将读取和写入方面隔离可以产生更具可维护性和灵活性的模型。
  大多数复杂的业务逻辑都进入编写模型。读取模型可以相对简单。
* **更简单的查询**。通过在读数据库中存储物化视图，应用程序可以避免查询时的复杂连接。

# 实现问题与注意事项

实现这一模式的一些挑战包括:

* **复杂性**。CQRS 的基本思想很简单。但是它可能导致更复杂的应用程序设计，特别是如果它们包含事件源模式的话。
* **消息**。虽然 CQRS 不需要消息传递，但是通常使用消息传递来处理命令和发布更新事件。
  在这种情况下，应用程序必须处理消息失败或重复消息。有关处理具有不同优先级的命令，
  请参阅优先级队列（TODO: 链接到此模式）指南。
* **最终一致性**。如果将读取和写入数据库分开，则读取数据可能过时。
  必须更新读模型存储区以反映对写模型存储区的更改，而且当用户基于过期读数据发出请求时，可能很难检测到这种更改。

# 何时使用

在下列场景下考虑 CQRS:

* 许多用户并行访问相同数据的协作域。
  CQRS 允许您定义具有足够粒度的命令，以便在域级别最小化合并冲突，并且确实出现的冲突可以通过该命令合并。
* 基于任务的用户界面，用户可以通过一系列步骤或复杂的领域模型来完成复杂的过程。
  写入模型有一个完整的命令处理堆栈，其中包含业务逻辑、输入验证和业务验证。
  写模型可以将一组相关联的对象视为数据更改的单个单元(DDD 术语中的聚合) ，并确保这些对象始终处于一致的状态。
  读取模型没有业务逻辑或验证堆栈，只是返回一个用于视图模型的 DTO。读模型最终与写模型保持一致。
* 必须将数据读取的性能与数据写入的性能分开进行微调的场景，特别是当读取的数量远大于写入的数量时。
  在这个场景中，您可以扩展读模型，但是只在少数几个实例上运行写模型。
  少量的写模型实例也有助于最小化合并冲突的发生。
* 一个开发团队可以关注作为写模型一部分的复杂领域模型，而另一个团队可以关注读模型和用户界面的场景。
* 预计系统将随时间演变并可能包含模型的多个版本的场景，或者业务规则定期更改的场景。
* 与其他系统的集成，尤其是与事件源相结合的集成，其中一个子系统的时间故障不应该影响其他子系统的可用性。

下列情况下不推荐使用这种模式:

* 域或业务规则很简单。
* 一个简单的 CRUD 风格的用户界面和数据访问操作就足够了。

考虑将 CQRS 应用到系统中最有价值的部分。

# 事件溯源与 CQRS

CQRS 模式通常与事件源模式一起使用。
基于 CQRS 的系统使用单独的读写数据模型，每个模型都适合相关任务，并且通常位于物理上独立的存储区中。
当与事件采购模式（TODO: 链接到此模式）一起使用时，事件的存储就是写模型，并且是正式的信息源。
基于 CQRS 的系统的读取模型提供数据的物化视图，通常是高度非规范化的视图。
这些视图是根据应用程序的接口和显示需求量身定制的，这有助于最大限度地提高显示和查询性能。

使用事件流作为写存储，而不是某个时间点的实际数据，可以避免单个聚合上的更新冲突，
并最大限度地提高性能和可伸缩性。这些事件可用于异步生成用于填充读取存储区的数据的物化视图。

由于事件存储是官方信息源，因此可以删除物化视图并重播所有过去的事件，
以便在系统发展时或在读取模型必须更改时创建当前状态的新表示。物化视图实际上是数据的持久只读缓存。

当使用 CQRS 与事件采购模式相结合时，请考虑以下几点:

* 与任何写存储和读存储分离的系统一样，基于此模式的系统最终只能保持一致。在生成事件和更新数据存储之间将有一些延迟。
* 模式增加了复杂性，因为必须创建代码来启动和处理事件，并组装或更新查询或读模型所需的适当视图或对象。
  与事件源模式一起使用时，CQRS 模式的复杂性使得成功的实现更加困难，并且需要一种不同的系统设计方法。
  但是，事件源可以使对域进行建模变得更加容易，并且使重新构建视图或创建新视图变得更加容易，
  因为数据中的更改意图得到了保留。
* 通过重播和处理特定实体或实体集合的事件，生成用于数据读取模型或预测的具体化视图，
  可能需要大量的处理时间和资源使用。如果需要对长时间的值进行求和或分析，则尤其如此，
  因为可能需要检查所有相关联的事件。
  通过按计划间隔实现数据快照(例如已发生的特定操作的总计数或实体的当前状态)来解决这个问题。



