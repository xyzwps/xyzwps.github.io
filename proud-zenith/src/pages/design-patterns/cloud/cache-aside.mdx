---
title: Cache-Aside Pattern
translateFrom: https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside
---

根据需要将数据从数据存储区加载到缓存中。
这可以提高性能，还有助于维护缓存中保存的数据与基础数据存储区中的数据之间的一致性。

# 问题背景

应用程序使用缓存来改进对数据存储中保存的信息的重复访问。
然而，期望缓存的数据始终与数据存储中的数据完全一致是不切实际的。
应用程序应该实现一种策略，该策略有助于确保缓存中的数据尽可能是最新的，
但也可以检测和处理缓存中的数据变得过时时出现的情况。

# 解决方案

许多商业缓存系统提供了 read-through 和 write-through/write-behind 操作。
在这些系统中，应用程序通过引用缓存来检索数据。
如果数据不在缓存中，则从数据存储中检索数据并添加到缓存中。
对缓存中保存的数据的任何修改也会自动写回数据存储。

对于不提供此功能的缓存，使用缓存来维护数据的应用程序负责。

应用程序可以通过实现缓存旁置策略来模拟通读缓存的功能。
此策略根据需要将数据加载到缓存中。该图说明了如何使用 Cache-Side 模式在缓存中存储数据。

![cache aside](/asset/img/cache-aside-diagram.png)

如果应用程序更新信息，它可以遵循 write-through 策略，对数据存储区进行修改，并使缓存中的相应项失效。

当下一次需要该项时，使用缓存旁置策略将导致从数据存储区检索更新的数据并将其添加回缓存中。

# 问题与注意事项

在决定如何实现此模式时，请考虑以下几点:

**缓存数据的生存期**。
许多缓存实现了一个过期策略，该策略使数据无效，如果在指定的时间段内没有访问数据，则将其从缓存中删除。
为了使缓存保持有效，请确保过期策略与使用数据的应用程序的访问模式匹配。
不要让过期时间太短，因为这会导致应用程序不断地从数据存储中检索数据并将其添加到缓存中。
类似地，不要让过期时间过长，以免缓存的数据变得过时。
请记住，缓存对于相对静态的数据或经常读取的数据是最有效的。

**驱逐数据**。
与数据源的数据存储区相比，大多数缓存的大小都有限，如果有必要，它们会排除数据。
大多数缓存采用最近使用次数最少的策略来选择要清除的项，但这可能是可定制的。
配置缓存的全局过期属性和其他属性以及每个缓存项的过期属性，以确保缓存的成本效益。
对缓存中的每个项应用全局清除策略并不总是合适的。
例如，如果从数据存储中检索缓存的项非常昂贵，那么将该项保留在缓存中可能是有益的，
但代价是更频繁地访问但代价较低的项。

**启动缓存**。
许多解决方案在缓存中预填充应用程序在启动处理过程中可能需要的数据。
如果其中一些数据过期或被清除，Cache-Side 模式仍然有用。

**一致性**。
实现 Cache-Side 模式并不能保证数据存储和缓存之间的一致性。
外部进程可以随时更改数据存储区中的项，这种更改可能要到下次加载该项时才会反映在缓存中。
在跨数据存储区复制数据的系统中，如果频繁发生同步，这个问题可能会变得严重。

**本地(内存中)缓存**。
缓存可以是应用程序实例的本地缓存并存储在内存中。
如果应用程序重复访问相同的数据，则缓存旁路在此环境中非常有用。
但是，本地缓存是私有的，因此不同的应用程序实例可以各自拥有相同的缓存数据的副本。
这些数据在缓存之间可能会很快变得不一致，因此可能需要过期保存在私有缓存中的数据并更频繁地刷新它。
在这些场景中，请考虑研究共享缓存机制或分布式缓存机制的使用。

# 何时使用

以下场景适用：

* 缓存不提供本机通读和通写操作。
* 资源需求是不可预测的。此模式使应用程序能够根据需要加载数据。它不假设应用程序预先需要哪些数据。

以下场景可能不适用：

* 当缓存的数据集是静态的时候。
  如果数据适合可用的缓存空间，那么在启动时用数据填充缓存，并应用防止数据过期的策略。
* 用于在驻留在 Web 农场中的 Web 应用程序中缓存会话状态信息。
  在这种环境中，应该避免引入基于客户机-服务器关联的依赖关系。
