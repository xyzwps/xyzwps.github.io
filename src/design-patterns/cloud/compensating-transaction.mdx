---
title: 补偿事务模式
translateFrom: https://docs.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction
---

撤消由一系列步骤执行的工作，如果一个或多个步骤失败，这些步骤将共同定义最终一致的操作。
遵循最终一致性模式的操作通常存在于实现复杂业务流程和工作流的云托管应用程序中。

# 问题背景

在云中运行的应用程序经常修改数据。这些数据可能分布在不同地理位置的各种数据源中。
为了避免争用和提高分布式环境中的性能，应用程序不应该尝试提供强的事务一致性。
相反，应用程序应该实现最终一致性。在这个模型中，典型的业务操作由一系列单独的步骤组成。
当执行这些步骤时，系统状态的总体视图可能不一致，但是当操作完成并且所有步骤都已执行时，
系统应该再次变得一致。

> [数据一致性入门](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10))
> 提供了关于为什么分布式事务不能很好地扩展的信息，以及最终一致性模型的原理。

最终一致性模式面临的一个挑战是，如何处理一个失败的步骤。
在这种情况下，可能需要撤消操作中前面步骤完成的所有工作。
但是，不能简单地回滚数据，因为应用程序的其他并发实例可能已经更改了数据。
即使在数据没有被并发实例更改的情况下，撤消一个步骤也可能不仅仅是恢复原始状态的问题。
可能需要应用各种特定于业务的规则(参见示例部分中描述的旅游网站)。

如果实现最终一致性的操作跨越多个异构数据存储区，撤消操作中的步骤将需要依次访问每个数据存储区。
必须可靠地撤销在每个数据存储中执行的工作，以防止系统保持不一致。

并非所有受实现最终一致性操作影响的数据都可能保存在数据库中。
在面向服务的体系结构(SOA)环境中，操作可以调用服务中的某个操作，并导致该服务持有的状态发生变化。
若要撤消操作，还必须撤消此状态更改。
这个过程可能涉及到再次调用服务并执行另一个操作来逆转第一个操作的效果。

# 解决方案

解决方案是实现补偿事务。补偿事务中的步骤必须撤消原始操作中步骤的效果。
补偿事务可能不能简单地将当前状态替换为操作开始时系统所处的状态，
因为这种方法可能会覆盖应用程序的其他并发实例所做的更改。
相反，它必须是一个考虑到并发实例所做的任何工作的智能流程。
这个过程通常是特定于应用程序的，由原始操作执行的工作的性质驱动。

一种常见的方法是使用工作流来实现最终一致的需要补偿的操作。
随着原始操作的进行，系统会记录关于每个步骤的信息，以及如何撤消该步骤执行的工作。
如果操作在任何时候失败，工作流将回退到它已经完成的步骤，并执行每个步骤的反向工作。
注意，补偿事务可能不必按原始操作的完全相反顺序撤消工作，并且可以并行执行一些撤消步骤。

> 这种方法类似于 [Clemens Vasters 博客中讨论的 Saga 策略](https://vasters.com/archive/Sagas.html)。

补偿事务也是最终一致的操作，它也可能失败。
系统应该能够在故障点恢复补偿事务并继续。
可能需要重复一个失败的步骤，因此补偿事务中的步骤应该定义为幂等命令。
欲了解更多信息，请参阅 Jonathan Oliver 的博客中的“[幂等模式](https://blog.jonathanoliver.com/idempotency-patterns/)”。

在某些情况下，除非通过人工干预，否则可能无法从失败的步骤中恢复过来。
在这些情况下，系统应该发出警报，并提供尽可能多的关于故障原因的信息。

# 问题与注意事项

在决定如何实现此模式时，请考虑以下几点:

确定实现最终一致性的操作步骤何时失败可能并不容易。
步骤可能不会立即失败，而是会阻塞。可能需要实现某种形式的超时机制。

补偿逻辑不容易推广。补偿事务是特定于应用程序的。
它依赖于应用程序拥有足够的信息，能够撤消失败操作中每个步骤的影响。

将补偿事务中的步骤定义为幂等命令。然后，如果补偿事务本身失败，可以重复这些步骤。

处理原始操作中的步骤和补偿事务的基础结构必须具有弹性。
它不能丢失补偿失败步骤所需的信息，它必须能够可靠地监视补偿逻辑的进展。

补偿事务不一定将系统中的数据返回到原始操作开始时的状态。
相反，它补偿了在操作失败之前成功完成的步骤所执行的工作。

补偿事务中步骤的顺序不一定与原始操作中的步骤完全相反。
例如，一个数据存储区可能比另一个数据存储区对不一致更敏感，
因此补偿事务中撤消对该存储区的更改的步骤应该首先发生。

在每个完成操作所需的资源上放置一个基于短期超时的锁，并提前获得这些资源，
可以帮助增加整个活动成功的可能性。只有在获得所有资源之后才能执行工作。
所有操作必须在锁过期之前完成。

考虑使用比通常更宽容的重试逻辑，以尽量减少触发补偿事务的失败。
如果实现最终一致性的操作中的某个步骤失败，尝试将失败作为暂时异常处理，然后重复该步骤。
只有在步骤重复失败或无法恢复时，才停止操作并启动补偿事务。

> 实施补偿交易的许多挑战与实施最终一致性的挑战相同。
> 有关详细信息，请参阅[数据一致性入门](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10))
> 中实现最终一致性的注意事项一节。

# 何时使用

此模式仅用于在操作失败时必须撤消的操作。如果可能，设计解决方案以避免需要补偿事务的复杂性。

# 示例

旅游网站允许客户预订行程。一个单一的行程可能包括一系列的航班和酒店。
从西雅图到伦敦再到巴黎的客户在制定行程时可以执行以下步骤:

1. 订一张从西雅图飞往伦敦的 F1航班的机票。
1. 订一张从伦敦飞往巴黎的 F2航班的机票。
1. 订一张从巴黎飞往西雅图的 F3航班的机票。
1. 在伦敦 H1酒店预订一个房间。
1. 在巴黎 H2酒店预订一个房间。

这些步骤构成了最终一致的操作，尽管每个步骤是一个单独的操作。
因此，除了执行这些步骤之外，系统还必须记录撤消每个步骤所需的计数器操作，以防客户决定取消行程。
然后，执行计数器操作所需的步骤可以作为补偿事务运行。

注意，补偿事务中的步骤可能与原始步骤不完全相反，
补偿事务中每个步骤中的逻辑必须考虑到任何特定于业务的规则。
例如，取消预订航班上的座位可能不会使客户有权获得任何已付款项的全额退款。
该图演示了如何生成一个补偿事务，以撤消长时间运行的事务，从而预订旅行行程。

![补偿事务图](/asset/img/compensating-transaction-diagram.png)

提示：补偿事务中的步骤可以并行执行，这取决于您如何为每个步骤设计补偿逻辑。

在许多业务解决方案中，单个步骤的失败并不总是需要使用补偿事务回滚系统。
例如，如果ーー在旅游网站场景中预订了 F1、 F2和 F3航班后ーー客户无法在 H1酒店预订房间，
最好是在同一城市的另一家酒店为客户提供一个房间，而不是取消航班。
客户仍然可以决定取消(在这种情况下，补偿事务运行并取消在 F1、 F2和 F3航班上的预订) ，
但是这个决定应该由客户而不是系统做出。




