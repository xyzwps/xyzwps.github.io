---
title: Competing Consumers Pattern
translateFrom: https://docs.microsoft.com/en-us/azure/architecture/patterns/competing-consumers
---

允许多个并发使用者处理在同一消息传递通道上接收的消息。
对于多个并发消费者，系统可以同时处理多个消息，以优化吞吐量，提高可伸缩性和可用性，并平衡工作负载。

# 问题背景

在云中运行的应用程序需要处理大量请求。
通常的技术不是同步处理每个请求，
而是让应用程序通过消息传递系统将请求传递给异步处理请求的另一个服务(使用者服务)。
这种策略有助于确保在处理请求时不会阻塞应用程序中的业务逻辑。

由于许多原因，请求的数量可能会随着时间的推移而发生很大的变化。
用户活动的突然增加或来自多个租户的聚合请求可能导致不可预测的工作负载。
在高峰时期，系统可能需要每秒处理数百个请求，而在其他时候，这个数字可能非常小。
此外，为处理这些请求而执行的工作的性质可能是高度可变的。
通过使用使用者服务的单个实例，可以使该实例充满请求。
或者，来自应用程序的大量消息可能使消息传递系统超载。
为了处理这种波动的工作负载，系统可以运行使用者服务的多个实例。
但是，必须对这些使用者进行协调，以确保每个消息只传递给单个使用者。
工作负载还需要在使用者之间进行负载平衡，以防止实例成为瓶颈。

# 解决方案

使用消息队列实现应用程序与使用者服务实例之间的通信通道。
应用程序以消息的形式将请求发送到队列，使用者服务实例从队列接收消息并处理它们。
此方法使相同的使用者服务实例池能够处理来自应用程序任何实例的消息。
该图说明了如何使用消息队列将工作分发到服务的实例。

![竞争消费者图](/asset/img/competing-consumers-diagram.png)

这个解决方案有以下好处：

* 它提供了一个负载级别的（load-leveled）系统，可以处理应用程序实例发送的请求数量的巨大变化。
  队列充当应用程序实例和使用者服务实例之间的缓冲区。
  这个缓冲区可以帮助应用程序和服务实例最小化对可用性和响应性的影响。
  有关更多信息，请参见基于队列的负载均衡模式(TODO: 链接到此模式)。
  处理需要长时间运行处理的消息并不能防止其他消息被使用者服务的其他实例并发处理。
* 它提高了可靠性。如果生产者直接与消费者通信而不使用此模式，但不监视消费者，
  那么如果消费者失败，消息很可能丢失或无法处理。在此模式中，消息不会发送到特定的服务实例。
  失败的服务实例不会阻塞生产者，消息可以由任何工作服务实例处理。
* 它不需要消费者之间，或者生产者和消费者实例之间的复杂协调。消息队列确保每条消息至少传递一次。
* 这是可扩展的。随着消息量的波动，系统可以动态地增加或减少消费者服务的数量。
* 如果消息队列提供事务性读操作，则可以提高弹性。
  如果使用者服务实例作为事务操作的一部分读取和处理消息，并且使用者服务实例失败，
  则此模式可以确保将消息返回到队列，由使用者服务的另一个实例拾取和处理。

# 问题与注意事项

在决定如何实现此模式时，请考虑以下几点:

* **消息顺序**。消费者服务实例接收消息的顺序不能得到保证，也不一定反映创建消息的顺序。
  设计系统以确保消息处理是幂等的，因为这将有助于消除对消息处理顺序的任何依赖性。
  有关更多信息，请参见 Jonathon Oliver 的博客中的[幂等性模式](https://blog.jonathanoliver.com/idempotency-patterns/)。
* **为弹性设计服务**。如果系统的设计是为了检测和重新启动失败的服务实例，
  那么可能有必要将服务实例执行的处理作为幂等操作来实现，
  以最小化检索和处理多次的单个消息的影响。
* **检测有毒信息**。格式不正确的消息或需要访问不可用资源的任务可能导致服务实例失败。
  系统应该防止这样的消息被返回到队列中，而应该在其他地方捕获和存储这些消息的细节，
  以便在必要时可以对它们进行分析。
* **处理结果**。处理消息的服务实例与生成消息的应用程序逻辑完全解耦，它们可能无法直接通信。
  如果服务实例生成的结果必须传递回应用程序逻辑，则此信息必须存储在两者都可访问的位置。
  为了防止应用程序逻辑检索不完整的数据，系统必须指示何时处理完成。
* **扩展（scale）消息传递系统**。在大规模解决方案中，单个消息队列可能会被消息数量淹没，
  成为系统中的瓶颈。在这种情况下，可以考虑对消息传递系统进行分区，
  将消息从特定的生产者发送到特定的队列，或者使用负载平衡将消息分布到多个消息队列。
* **确保消息传递系统的可靠性**。
  需要一个可靠的消息传递系统来保证应用程序在排列消息之后不会丢失消息。
  该系统对于确保所有消息至少传递一次至关重要。

# 何时使用

以下场景可以使用此模式：

* 应用程序的工作负载分为可以异步运行的任务。
* 任务是独立的，可以并行运行。
* 工作量是高度可变的，需要一个可伸缩的解决方案。
* 解决方案必须提供高可用性，并且在任务处理失败时必须具有弹性。

下面的场景可能不大适合：

* 将应用程序工作负载分离为离散的任务并不容易，或者任务之间存在高度依赖性。
* 任务必须同步执行，应用程序逻辑必须等待任务完成后才能继续。
* 任务必须按照特定的顺序执行。

> 一些消息传递系统支持使生产者能够将消息分组在一起并确保它们都由同一个消费者处理的会话。
> 这种机制可以与已排序的消息(如果支持的话)一起使用，以实现一种消息排序形式，
> 该形式按顺序将消息从生产者传递到单个消费者。