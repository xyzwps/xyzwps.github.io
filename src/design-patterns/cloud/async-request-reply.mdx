---
title: Asynchronous Request-Reply Pattern
translateFrom: https://docs.microsoft.com/en-us/azure/architecture/patterns/async-request-reply
---

从前端主机解耦后端处理，后端处理需要是异步的，但前端仍然需要一个明确的响应。

# 问题背景

在现代应用程序开发中，客户机应用程序(通常是在 Web 客户机(浏览器)中运行的代码)通常依赖于远程 API
来提供业务逻辑和组合功能。这些 API 可能与应用程序直接相关，也可能是由第三方提供的共享服务。
通常，这些 API 调用通过 HTTP (S)协议进行，并遵循 REST 语义。

在大多数情况下，客户端应用程序的 API 被设计为快速响应，响应时间在100毫秒或更少。
许多因素可以影响响应延迟，包括:

* An application's hosting stack.
* 安全组件
* 调用方和后端的相对地理位置
* 网络基础设施
* 请求负载的大小
* 处理队列的长度
* 后端处理请求的时间

这些因素中的任何一个都可能增加响应的延迟。
有些可以通过扩展后端来减轻。其他的，比如网络基础设施，在很大程度上不受应用程序开发人员的控制。
大多数 API 可以快速响应，以便通过相同的连接返回响应。
应用程序代码可以以非阻塞的方式进行同步 API 调用，给出异步处理的外观，这是 I/O 密集型操作所推荐的。

然而，在某些场景中，后端完成的工作可能是长时间运行的，以秒为单位，
或者可能是在几分钟甚至几小时内执行的后台进程。
在这种情况下，在响应请求之前等待工作完成是不可行的。
这种情况对于任何同步请求-应答模式都是一个潜在的问题。

有些体系结构通过使用消息代理来分隔请求和响应阶段来解决这个问题。
这种分离通常通过使用基于队列的负载均衡模式来实现（TODO: 链接到这个模式）。
这种分离可以允许客户端进程和后端 API 独立伸缩。
但是，当客户机需要成功通知时，这种分离也带来了额外的复杂性，因为这个步骤需要成为异步的。

在分布式系统(例如微服务体系结构)中，服务器到服务器的 REST API 调用也需要考虑许多与客户机应用程序相同的因素。

# 解决方案

这个问题的一个解决方案是使用 HTTP 轮询（polling）。
轮询对于客户端代码非常有用，因为很难提供回调端点或使用长时间运行的连接。
即使回调是可能的，所需的额外库和服务有时也会增加太多额外的复杂性。

* 客户端应用程序对 API 进行同步调用，触发后端的长时间运行操作。
* API 尽可能快地同步响应。它返回一个 HTTP202(Accepted)状态代码，确认已收到请求进行处理。
  注意:
  在启动长时间运行的流程之前，API 应该同时验证请求和要执行的操作。
  如果请求无效，则立即使用错误代码(如 HTTP400(Bad Request))进行响应。
* 响应持有一个指向端点的位置引用，客户端可以轮询该端点以检查长时间运行操作的结果。
* API 将处理工作卸载到另一个组件，如消息队列。
* 对于每次成功调用状态端点，它都返回 HTTP202。
  当工作仍未完成时，状态端点返回一个资源，该资源指示工作仍在进行中。
  一旦工作完成，状态端点可以返回指示完成的资源，或者重定向到另一个资源 URL。
  例如，如果异步操作创建新资源，则状态端点将重定向到该资源的 URL。

下图是一个典型的流程：

![async-request](/asset/img/async-request.png)

1. 客户端发送请求并接收 HTTP202(Accepted)响应。
1. 客户机向状态端点发送一个 HTTP GET 请求。这项工作仍然悬而未决，因此此调用返回 HTTP200。
1. 在某个时刻，工作已经完成，状态端点返回重定向到资源的302(Found)。
1. 客户端从指定的 URL 获取资源。

# 问题与注意事项

* 有许多可能的方法可以通过 HTTP 实现这种模式，而且并非所有的上游服务都具有相同的语义。
  例如，当远程进程尚未完成时，大多数服务不会从 GET 方法返回 HTTP202响应。
  遵循纯 REST 语义，它们应该返回 HTTP404(Not Found)。
  当您考虑到调用的结果还没有出现时，这个响应是有意义的。
* HTTP 202 响应应该指示客户端应该轮询响应的位置和频率。它应该有下列额外的 http 头:
  | 头          | 描述       | 说明       |
  |-------------|-----------|------------|
  | Location    | 客户端应该轮询以获得响应状态的 URL | 如果这个位置需要访问控制，这个 URL 可以是一个具有合适的代理密钥模式（TODO: 链接到这个模式）的 SAS 令牌。当响应轮询需要转移到另一个后端时，代客密钥模式也是有效的  |
  | Retry-After | 估计何时完成处理 | 这个消息头的设计目的是防止轮询客户端用重试压垮后端。 |
* 您可能需要使用处理代理或 facade 来操作响应头或负载，具体取决于所使用的基础服务。
* 如果状态端点在完成时重定向，则 HTTP302或 HTTP303都是适当的返回代码，
  具体取决于您支持的确切语义。
* 处理成功后，Location 头指定的资源应该返回适当的 HTTP 响应代码，如200(OK)、
  201(Created)或204(No Content)。
* 如果在处理过程中发生错误，将错误保存在资源的 Location 头详情描述地址，
  最好从该资源返回一个适当的响应代码(4xx 代码)给客户端。
* 并非所有的解决方案都以相同的方式实现这种模式，有些服务将包含额外的或备用的头。
  例如，Azure 资源管理器使用此模式的修改变体。
* 遗留客户端可能不支持此模式。在这种情况下，您可能需要在异步 API 上放置一个 facade，
  以便向原始客户机隐藏异步处理。例如，Azure Logic Apps 本身支持这种模式，
  可以作为异步 API 和进行同步调用的客户端之间的集成层使用。
  请参见[使用 webhook 操作模式执行长时间运行的任务](https://docs.microsoft.com/en-us/azure/logic-apps/logic-apps-create-api-app#perform-long-running-tasks-with-the-webhook-action-pattern)。
* 在某些情况下，您可能希望为客户端提供一种方法来取消长时间运行的请求。
  在这种情况下，后端服务必须支持某种形式的取消指令。

# 何时使用

此模式适用于：

* 客户端代码(如浏览器应用程序)很难提供回调端点，或者使用长时间运行的连接增加了太多额外的复杂性。
* 由于客户端的防火墙限制，只有 HTTP 协议可用且返回服务不能触发回调的服务调用。
* 需要与不支持现代回调技术(如 WebSocket 或 webhook)的遗留体系结构集成的服务调用。

以下场景可能不适用：

* 您可以使用为异步通知而构建的服务，例如 Azure Event Grid。
* 响应必须实时流到客户端。
* 客户机需要收集许多结果，并且这些结果的接收延迟非常重要。请考虑一种服务总线模式。
* 您可以使用服务器端持久性网络连接，如 WebSocket 或 SignalR。这些服务可用于通知调用方结果。
* 网络设计允许您打开端口以接收异步回调或 webhook。