---
layout: ../../../layouts/MdxLayout.astro
title: Competing Consumers pattern
parent:
  name: 返回上级
  path: /cheatsheet/cloud-patterns/
translateFrom:
  url: https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers
  title: Competing Consumers pattern - Azure Architecture Center
---

TODO: 翻译很奇怪

使多个并发消费者能够处理在同一消息传递通道上接收到的消息。
有了多个并发消费者，系统可以同时处理多个消息，以优化吞吐量，提高可扩展性和可用性，并平衡工作负载。

## 问题上下文

在云中运行的应用程序需要处理大量请求。
一个常见的技术不是同步处理每个请求，而是应用程序通过消息传递系统将它们传递给另一个异步处理它们的服务（消费者服务）。
这种策略有助于确保在处理请求时应用程序中的业务逻辑不被阻塞。

由于许多原因，请求的数量可能会随着时间的推移而显著变化。
用户活动的突然增加或来自多个租户的聚合请求会导致不可预测的工作负载。
在高峰时段，系统可能需要每秒处理数百个请求，而在其他时候，数量可能非常小。
此外，为处理这些请求而执行的工作的性质可能变化很大。通过使用消费者服务的单个实例，您可以导致该实例被请求淹没。
或者，消息传递系统可能会因来自应用程序的消息涌入而超载。为了处理这种波动的工作负载，系统可以运行消费者服务的多个实例。
但是，必须协调这些消费者，以确保每条消息只传递给单个消费者。工作负载还需要跨消费者进行负载平衡，以防止实例成为瓶颈。

## 解决方案

使用消息队列来实现应用程序和消费者服务实例之间的通信通道。
应用程序以消息的形式向队列发布请求，消费者服务实例从队列接收消息并对其进行处理。
这种方法使相同的消费者服务实例池能够处理来自应用程序任何实例的消息。
该图说明了使用消息队列将工作分配给服务实例。

![](https://learn.microsoft.com/en-us/azure/architecture/patterns/_images/competing-consumers-diagram.png)

注意：尽管这些消息有多个消费者，但这与发布订阅模式（pub/sub）不同。
使用竞争消费者方法，每条消息都传递给单个消费者进行处理，而使用Pub/Sub方法，所有消费者都会传递每条消息。

该解决方案具有以下好处：

- 它提供了一个负载均衡系统，可以处理应用程序实例发送的大量请求。
  队列充当应用程序实例和消费者服务实例之间的缓冲区。
  该缓冲区有助于最大限度地减少对应用程序和服务实例的可用性和响应能力的影响。
  有关详细信息，请参阅[基于队列的负载均衡模式](/cheatsheet/cloud-patterns/queue-based-load-leveling)。
  处理需要长时间运行处理的消息不会阻止消费者服务的其他实例同时处理其他消息。

- 它提高了可靠性。如果生产者直接与消费者通信，而不是使用这种模式，但不监控消费者，如果消费者失败，消息很有可能丢失或无法处理。
  在这种模式中，消息不会发送到特定的服务实例。失败的服务实例不会阻止生产者，任何工作的服务实例都可以处理消息。

- 它不需要消费者之间或生产者和消费者实例之间的复杂协调。消息队列确保每条消息至少传递一次。

- 它是可扩展的。当您应用自动缩放时，系统可以随着消息量的波动而动态增加或减少消费者服务的实例数量。

- 如果消息队列提供事务性读取操作，它可以提高弹性。
  如果消费者服务实例作为事务性操作的一部分读取和处理消息，并且消费者服务实例失败，
  这种模式可以确保消息将返回到队列中，由消费者服务的另一个实例拾取和处理。
  为了降低消息持续失败的风险，我们建议您使用死信队列。

## 实现考量

在决定如何实现此模式时，请考虑以下几点：

- **消息排序**。消费者服务实例接收消息的顺序不能保证，也不一定反映消息创建的顺序。
  设计系统以确保消息处理是幂等的，因为这将有助于消除对消息处理顺序的任何依赖。
  有关详细信息，请参阅JonathonOliver博客上的幂等模式。

- 设计具有弹性的服务。
  如果系统旨在检测和重新启动失败的服务实例，则可能需要将服务实例执行的处理实现为幂等操作，以最小化多次检索和处理单个消息的影响。

- 检测有害消息。格式错误的消息或需要访问不可用资源的任务可能会导致服务实例失败。
  系统应防止此类消息返回到队列，而是捕获这些消息的详细信息并将其存储在其他地方，以便在必要时对其进行分析。

- 处理结果。处理消息的服务实例与生成消息的应用程序逻辑完全分离，它们可能无法直接通信。
  如果服务实例生成的结果必须传回应用程序逻辑，则此信息必须存储在两者都可以访问的位置。
  为了防止应用程序逻辑检索不完整的数据，系统必须在处理完成时指示。

- 扩展消息传递系统。在大规模解决方案中，单个消息队列可能会被消息数量淹没，成为系统中的瓶颈。
  在这种情况下，考虑对消息传递系统进行分区，以将消息从特定生产者发送到特定队列，或者使用负载平衡跨多个消息队列分发消息。

- 确保消息传递系统的可靠性。需要一个可靠的消息传递系统来保证应用程序在将消息排队后不会丢失。
  该系统对于确保所有消息至少传递一次至关重要。

## 何时使用

以下场景可使用此模式：

- 应用程序的工作负载分为可以异步运行的任务。
- 任务是独立的，可以并行运行。
- 工作量变化很大，需要可扩展的解决方案。
- 解决方案必须提供高可用性，并且在任务处理失败时必须具有弹性。

在以下情况下，此模式可能没有用：

- 将应用程序工作负载分成离散的任务并不容易，或者任务之间存在高度依赖关系。
- 任务必须同步执行，并且应用程序逻辑必须等待任务完成才能继续。
- 任务必须按特定顺序执行。

> 一些消息传递系统支持使生产者能够将消息组合在一起并确保它们都由同一个消费者处理的会话。
> 这种机制可以与优先消息（如果支持的话）一起使用，以实现一种消息排序形式，将消息按顺序从生产者传递到单个消费者。