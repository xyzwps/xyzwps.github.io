---
layout: ../../../layouts/MdxLayout.astro
title: Cache-Aside Pattern
parent:
  name: 返回上级
  path: /cheatsheet/cloud-patterns/
translateFrom:
  url: https://learn.microsoft.com/en-us/azure/architecture/patterns/cache-aside
  title: Cache-Aside pattern - Azure Architecture Center
---

按需把数据存储中的数据加载进缓存中，可以提高性能。

## 问题上下文

若应用程序需要重复地从数据存储中读取信息，就可以使用缓存来提升性能。
不过，期望缓存中的数据，始终与数据存储中的数据完全一致，是不切实际的。
应用程序不仅要检测和处理缓存中的数据过期的情况，还要采取措施，确保缓存中的数据尽可能最新的。

## 解决方案

许多商业缓存系统提供 read-through 和 write-through/write-behind 操作。
在这些系统中，应用程序通过缓存来获取数据。
如果数据不在缓存中，则从数据存储中读取数据，并将数据加载到缓存中。
任何对缓存中保存的数据的修改，也会自动写回数据存储。

对于不提供此功能的缓存，使用缓存的应用程序来负责维护数据。

应用程序可以通过实现 cache-aside 模式，来模拟 read-through 缓存的功能。
此模式按需将数据加载到缓存中。步骤如下：

1. 确定数据是否存在缓存中。
2. 如果数据不存在缓存中，就从数据存储中读数据。
3. 把读到的数据存放在缓存中。

如果应用更新信数据，就使用以下策略：

1. 保存变更到数据存储。
2. 使缓存中的相应数据无效。

当下一次需要该数据时，使用 cache-aside 模式，把更新过的数据从数据存储中查出来，并将其加到缓存中。

## 实现考量

在实现此模式时，应考虑以下几点：

### 缓存数据的寿命

许多缓存都有过期策略：如果在指定时间段内未访问数据，则使数据无效并将其从缓存中删除。
要使此模式有效，应确保过期策略与使用数据的应用程序的访问模式相匹配。
过期时间不应太短，因为这会导致应用程序不断从数据存储中检索数据并将其添加到缓存中。
同样，过期时间不应过长，否则缓存的数据可能会变得陈旧。

请记住，缓存最适合相对静态的数据，或经常读取的数据。

### 驱逐缓存

与数据来源的数据存储相比，大多数缓存的大小都是有限的。如果需要，它们会驱逐数据。
大多数缓存采用 LRU 策略来选择要驱逐的项目，但也可能支持自定义的。
配置缓存的全局过期属性和其他属性，以及每个缓存项的过期属性，以确保缓存具有成本效益。
对缓存中的每个数据项都应用全局驱逐策略，并不总是合适的。
例如，如果从数据存储中查询缓存项的代价很高，那么相比于访问虽然频繁但是查询成本更低的项，将此项保留在缓存中可能是有益的。

### 启动缓存

许多方案喜欢在应用程序在启动过程中，把可能需要的数据预先填入缓存。
如果其中的数据过期或者被驱逐，此模式依然有用。

### 一致性

实现此模式并不保证数据存储和缓存之间的一致性。
外部过程可以随时更改数据存储中的数据项，并且在下次加载该项目之前，此更改可能不会反映在缓存中。
在跨数据存储复制数据的系统中，如果频繁发生同步，此问题可能会变得严重。

### 本地缓存/内存缓存

应用程序可以把缓存放到自己的本地内存中。
如果应用程序重复访问相同的数据，则本地缓存就会非常有效。
不过，本地缓存是私有的，因此不同的应用程序实例可能每个都有相同缓存数据的副本。
这时，可考虑使用共享或分布式缓存。

## 何时使用

以下场景可使用：

- 缓存不提供原生的 read-through 和 write-through 操作时。
- 资源需求是不可预测的。这种模式使应用程序能够按需加载数据。它不假设应用程序将提前需要哪些数据。

以下场景可能不适用：

- 当缓存的数据集是静态的。如果数据使用的缓存空间足够，应在启动时加载数据到缓存并防止数据过期。
- For caching session state information in a web application hosted in a web farm.
  In this environment, you should avoid introducing dependencies based on client-server affinity.


TODO: 搞清楚缓存的其他问题，比如写策略，等等

## 数据更新

缓存数据更新有几种策略：

- *Write-through*：不管缓存中是否有对应的数据，都先把数据写入缓存，再写入数据存储。
- *Write-around*：如果缓存中有对应的数据，就先更新缓存，再更新数据存储；如果没有，就直接更新数据存储。
- *Write-behind*/*Write-back*：不管缓存中是否有对应的数据，都先把数据写入缓存，之后再想办法写入数据存储。

## 其他参考

- [Cache Write Policy | Baeldung on Computer Science](https://www.baeldung.com/cs/cache-write-policy)