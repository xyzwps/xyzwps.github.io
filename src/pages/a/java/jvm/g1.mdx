---
layout: ../_BlogLayout.astro
title: G1
---

Garbage-First (G1)收集器是一个服务器风格的垃圾收集器，针对具有大内存的多处理器机器。
它以很高的概率满足 GC 暂停时间目标，同时实现高吞吐量。
OracleJDK7 update 4和之后的版本完全支持 G1垃圾收集器。
在 JDK TODO: 中，它成了默认收集器。
垃圾优先(G1)垃圾收集器针对具有大量内存的多处理器机器。
它试图以较高的概率满足垃圾收集暂停时间目标，同时在不需要配置的情况下实现高吞吐量。
G1旨在利用当前的目标应用程序和环境，在延迟和吞吐量之间实现最佳平衡，这些目标应用程序和环境的特性包括:

- 堆的大小可以达到数十GB甚至更大，其中超过50% 的 Java 堆被活数据占据。
- 对象分配和跨代提升的速率随时间变化很大。
- 堆中有大量碎片。
- 有可预测的暂停时间目标，不超过几百毫秒，避免长时间的垃圾收集暂停。

G1取代了并发标记扫描(CMS)收集器，它也是默认的收集器。 [CMS 在 JDK 14 中被移除](https://openjdk.org/jeps/363)。

G1计划作为并发标记扫描收集器(CMS)的长期替代品。比较 G1和 CMS，有差异，
使 G1成为一个更好的解决方案。
一个区别是 G1是一个压缩收集器。G1足够紧凑，完全避免使用细粒度的自由列表进行分配，
而是依赖于区域。这极大地简化了收集器的各个部分，并且最大限度地消除了潜在的碎片问题。
此外，与 CMS 收集器相比，G1提供了更多可预测的垃圾收集暂停，
并允许用户指定所需的暂停目标。

G1收集器实现了高性能，并尝试通过以下几个部分中描述的几种方式来满足暂停时间目标。

## 启用 G1

Garbage-First 垃圾收集器是默认的收集器（TODO: 哪个版本），因此通常不必执行任何其他操作。
您可以通过在命令行上提供 `-XX:+UseG1GC` 来显式地启用它。

## 基本概念

G1是一个分代的、增量的、并行的（主要是并发的）、停止世界(stop-the-world)和疏散垃圾收集器，
它监视每个停止世界(stop-the-world)暂停时间的目标。
与其他收集器类似，G1将堆分为(在概念上)年轻一代和老一代。
空间回收的努力集中在最有效率的年轻一代，偶尔在老一代的空间回收。

有些操作总是在停止世界时执行，以提高吞吐量。
停止应用程序需要更多时间的其他操作(如全局标记等整堆操作)与应用程序并行并发地执行。
为了保持停止世界短暂的空间回收，G1执行空间回收增量步骤和并行。
G1通过跟踪关于以前的应用程序行为和垃圾收集暂停的信息来建立相关成本的模型，从而实现可预测性。
它使用这些信息来衡量在暂停期间完成的工作。
例如，G1首先回收最有效的区域中的空间(即大部分被垃圾填充的区域，因此得名)。

G1主要通过使用撤离(evacuation)来回收空间: 
在选定的内存区域中发现的要收集的活动对象被复制到新的内存区域中，并在过程中压缩它们。
撤离完成后，活动对象先前占用的空间将被应用程序重用以进行分配。

Garbage-First 收集器不是实时收集器。
它试图在较长的时间内以较高的概率满足设定的暂停时间目标，但并不总是对给定的暂停具有绝对的确定性。

## 堆布局

G1将堆分割成一组大小相同的堆区域(region)，每个区域有一个连续的虚拟内存范围，如图9-1所示。
区域是内存分配和内存回收的单位。在任何给定的时间，这些区域中的每一个都可以是空的(浅灰色) ，
或者分配给特定的一代，年轻的或年老的。当内存请求进入时，内存管理器分发可用区域。
内存管理器将它们分配给一代，然后将它们作为空闲空间返回给应用程序，应用程序可以将自己分配到这些空间中。


年轻一代包括伊甸园区域(红色)和幸存者区域(红色带“ S”)。
这些区域提供与其他收集器中相应的连续空间相同的功能，不同之处在于，在 G1中，这些区域通常在内存中以非连续模式布局。
老地区(浅蓝色)组成了老一代。对于跨越多个区域的物体，老一代区域可能是巨大的(浅蓝色带“ H”)。

应用程序总是分配给年轻的一代，即伊甸园地区，除了那些直接分配给老一代的巨大对象。

G1垃圾收集暂停可以整体回收年轻代中的空间，并在任何收集暂停时回收任何额外的老代区域集。
在暂停期间，G1将此集合中的对象复制到堆中的一个或多个不同区域。
对象的目标区域取决于该对象的源区域: 将整个年轻一代复制到幸存者区域或旧区域，并使用老化将来自旧区域的对象复制到其他不同的旧区域。

## GC 周期

在高级别上，G1收集器在两个阶段之间交替。
Young-only 阶段包含垃圾收集，这些垃圾收集使用老一代中的对象逐渐填充当前可用的内存。
空间回收阶段是 G1在老一代中逐步回收空间的阶段，除了处理年轻一代。然后周期重新开始，只有年轻的阶段。

以下清单详细介绍了 G1垃圾收集周期的各个阶段及其暂停和各阶段之间的过渡:

1. 年轻阶段: 这个阶段开始于一些正常的年轻集合，将对象推广到老一代。
   当老一代的占用率达到一定的门槛，即启动堆占用门槛时，就开始从只有年轻人的阶段过渡到空间回收阶段。
   此时，G1调度并发启动年轻集合，而不是普通年轻集合。 
   * 并发开始: 这种类型的集合除了执行 Normal young 集合之外，还会启动标记过程。
     并发标记确定在下一个空间回收阶段保留旧代区域中的所有当前可到达(活动)对象。
     当集合标记尚未完全完成时，可能会出现正常的年轻集合。标记结束时有两个特殊的停止世界: 备注和清理。 
   * 注意: 这个暂停完成标记本身，执行全局引用处理和类卸载，回收完全空的区域，并清理内部数据结构。
     在 Remark 和 Cleanup G1之间计算信息，
     以便以后能够同时在选定的老一代区域中回收可用空间，这将在 Cleanup 暂停中完成。
   * 清理: 这个暂停决定了空间回收阶段是否真的会随之而来。如果接下来是一个空间回收阶段，
     那么只有 young 的阶段将使用单个 PreadMiedyoung 集合来完成。 
2. 空间回收阶段: 此阶段包括多个混合集合，除了年轻一代区域外，还撤离老一代区域集合的活动对象。
   空间回收阶段结束时，G1决定撤离更多的老一代地区不会产生足够的自由空间值得努力。

在空间回收之后，收集循环将重新启动另一个仅年轻的阶段。
作为备份，如果应用程序在收集活性信息时耗尽了内存，G1将像其他收集器一样执行就地停止全局完整堆压缩(Full GC)。

## G1 细节

### 确定初始化堆占用

初始堆占用百分比( Initiating Heap Occupancy Percent IHOP)是触发初始标记集合的阈值，它被定义为旧代大小的百分比。

默认情况下，G1通过观察在标记周期中标记需要多长时间以及老一代通常分配多少内存来自动确定最佳 IHOP。这个特性称为自适应 IHOP。
如果这个特性被启用的，那么选项 `-XX:InitiatingHeapOccupancyPercent` 将确定初始值作为当前老一代大小的百分比，
只要没有足够的观察值来对初始堆占用阈值做出良好的预测。使用选项 `-XX:-G1UseAdaptiveIHOP` 关闭 G1的这种行为。
在这种情况下 `-XX:InitiatingHeapOccupancyPercent` 的值始终确定此阈值。

在内部，AdaptiveIHOP 试图设置启动堆占用，以便当旧一代占用处于当前的最大旧一代大小减去作为额外缓冲区的
`-XX: G1HeapReservePercent` 的值时，空间回收阶段的第一个混合垃圾收集开始。


### Marking

G1标记使用一种称为开始时快照(SATB)的算法。
它在初始标记停顿时获取堆的虚拟快照，当所有在标记开始时处于活动状态的对象在标记的其余部分被视为处于活动状态时。
这意味着在标记过程中变得死亡(不可到达)的对象仍然被认为是活的，用于空间回收(除了一些例外)。
与其他收集器相比，这可能导致错误地保留了一些额外的内存。但是，SATB 可能在 Remark 暂停期间提供更好的延迟。
在该标记期间被认为过于保守的活动对象将在下一次标记期间被回收。有关标记问题的更多信息，请参见垃圾收集器优化主题。

### 非常紧密堆情况下的行为

当应用程序保持如此多的内存，以至于疏散无法找到足够的空间进行复制时，就会发生疏散失败。
疏散失败意味着 G1试图完成当前的垃圾收集，方法是将已经移动的对象保留在新位置，不复制任何尚未移动的对象，只调整对象之间的引用。
疏散失败可能会导致一些额外的开销，但通常应该与其他年轻的收集一样快。
在此垃圾收集与疏散失败后，G1将恢复正常的应用程序，没有任何其他措施。
G1假设疏散失败发生在接近垃圾收集结束的时候; 也就是说，大多数对象已经被移动，
并且有足够的空间继续运行应用程序，直到标记完成和空间回收开始。

如果这个假设不成立，那么 G1最终将安排一个 Full GC。此类型的集合执行整个堆的就地压缩。这可能会很慢。

有关分配失败或完全 GC 问题的更多信息，请参见垃圾收集器优化-首次垃圾收集器优化。

### 巨大对象

巨大的物体是比半个区域大或等于半个区域大的物体。除非使用 `-XX:G1HeapRegionSize` 选项进行设置，
否则当前区域大小将按照 G1 GC 部分的“人类工程学默认值”中的描述进行人类工程学确定。

这些巨大的物体有时被以特殊的方式处理: 

* 每个巨大的物体在老一代中被分配为一系列相邻的区域。
  对象本身的开始总是位于该序列的第一个区域的开始。
  序列的最后一个区域中的任何剩余空间都将丢失以进行分配，直到整个对象被回收。
* 通常，只有在清理暂停期间的标记结束时，或者在完全 GC 期间(如果它们变得无法访问) ，才可以回收大型对象。
  但是，对于基元类型的数组(例如 bool、所有类型的整数和浮点值) ，有一个特殊的庞大对象规定。
  如果在任何类型的垃圾收集暂停时，许多对象都没有引用巨大的对象，G1就会机会性地尝试收回它们。
  默认情况下启用此行为，但可以使用选项 `-XX:G1EagerReclaimHumongousObjects` 禁用它。
* 巨大对象的分配可能导致垃圾收集暂停过早发生。G1在每个巨大对象分配时检查初始堆占用阈值，
  如果当前占用超过该阈值，则可以立即强制初始标记 young 收集。
* 这些巨大的物体永远不会移动，即使在完全 GC 时也不会。
  这可能会导致过早地出现缓慢的全部 GC 或意外的内存不足情况，由于区域空间碎片，这些情况会留下大量可用空间。

## Young-Only Phase Generation Sizing

在仅年轻化阶段，要收集的区域集(收集集)仅由年轻一代区域组成。
G1总是在一个正常的年轻集合结束时为下一个突变体阶段测量年轻一代的大小。
通过这种方式，G1可以满足使用 `-XX:MaxGCPauseTimeMillis` 和 `-XX:PauseTimeIntervalMillis` 设置的暂停时间目标，
这些目标基于对实际暂停时间的长期观察。它考虑到了年轻一代需要多长时间才能撤离。
这包括诸如在收集期间必须复制多少对象以及这些对象之间的相互关联程度等信息。

如果没有其他约束，则 G1在 `-XX:G1NewSizePercent` 和 `-XX:G1MaxNewSizePercent`
决定满足暂停时间的值之间自适应地调整年轻一代的大小。
有关如何修复长暂停的更多信息，请参见垃圾-第一个垃圾收集器优化。

## Space-Reclamation Phase Generation Sizing

在空间回收阶段，G1试图在单个垃圾收集暂停中最大化老一代中回收的空间量。
年轻一代的大小被设置为最小允许值，通常由 `-XX:G1NewSizePercent` 确定，并且添加任何用于回收空间的老一代区域，
直到 G1确定添加更多区域将超过暂停时间目标。在特定的垃圾收集暂停中，
G1按照回收效率、最高优先级和获得最终收集集的剩余可用时间的顺序添加旧生成区域。

每次垃圾收集所需的老一代区域的数量在下端以要收集的潜在候选老一代区域(收集集候选区域)的数量为界，
除以由 `-XX:G1MixedGCCountTarget` 确定的空间回收阶段的长度。
集合集候选区域是所有在阶段开始时占用率小于 `-XX:G1MixedGCLiveThresholdPercent` 的老一代区域。

当集合集候选区域中可回收的剩余空间量小于-XX: G1HeapWastePercent 设置的百分比时，该阶段结束。

有关 G1将使用多少个旧版本区域以及如何避免长时间混合收集暂停的更多信息，请参见垃圾收集器优化-首次垃圾收集器优化。

## G1 GC 的人类工程学缺省值

本主题概述了特定于 G1的最重要的默认值及其默认值。它们给出了使用 G1的预期行为和资源使用情况的粗略概述，没有任何其他选项。


## 参考

- [Getting Started with the G1 Garbage Collector - Oracle](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html)
- [Garbage-First Garbage Collector - Oracle](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html)
- [G1: from garbage collector to waste management consultant](https://blogs.oracle.com/java/post/g1-from-garbage-collector-to-waste-management-consultant)
- [HotSpot Virtual Machine Garbage Collection Tuning Guide - 9 Garbage-First Garbage Collector](https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-g1-garbage-collector1.html)