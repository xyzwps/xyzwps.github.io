---
layout: ../_BlogLayout.astro
title: JVM 规范概览
---

本文只是大致列举一下可能和理解 GC 相关的 JVM 规范部分。更像详细的内容可以去
[Oracle 查看](https://docs.oracle.com/javase/specs/jvms/se20/html/jvms-2.html)。

要正确地实现 Java 虚拟机，您只需要能够读取 class 文件格式并正确地执行其中的指令即可。
实现细节不属于 Java 虚拟机规范，这意味着 JVM 的实现有很大的灵活性。
运行时数据区域的内存布局、所使用的垃圾收集算法以及 Java
虚拟机指令的任何内部优化(例如，将它们转换成机器代码)都由实现者自行决定。

## 运行时数据区

Java 虚拟机定义了在程序执行过程中使用的各种运行时数据区域。
其中一些数据区域是在 Java 虚拟机启动时创建的，只有当 Java 虚拟机终止时才会销毁。
其他数据区域属于每个线程。每个线程的数据区域是在创建线程时创建的，并在线程终止时销毁。

### PC 寄存器

Java 虚拟机可以同时支持多个执行线程(JLS 17)。每个 Java 虚拟机线程都有自己的 pc (程序计数器)寄存器。
在任何时候，每个 Java 虚拟机线程都只执行一个方法的代码，即该线程的当前方法。

### Java 虚拟机栈

每个 Java 虚拟机线程都有一个私有的 Java 虚拟机栈，该栈与该线程同时创建。
Java 虚拟机栈存储帧（*frame*）。Java 虚拟机栈类似于传统语言(如 C)的栈: 它保存局部变量和部分结果，并在方法调用和返回中发挥作用。
因为 Java 虚拟机栈除了推送和弹出帧之外不会被直接操作，所以帧可能会被堆分配。 TODO: 怎么理解
Java 虚拟机栈的内存不必是连续的。

规范允许 Java 虚拟机栈具有固定的大小，或者根据计算的需要动态扩展和收缩。
如果 Java 虚拟机栈的大小是固定的，那么在创建该栈时，可以独立地选择每个 Java 虚拟机栈的大小。

Java 虚拟机实现可以为程序员或用户提供对 Java 虚拟机栈初始大小的控制，
以及在动态扩展或收缩 Java 虚拟机栈的情况下，对最大和最小大小的控制。

与 Java 虚拟机堆栈相关的异常情况如下:

- 如果线程中的计算需要比允许的更大的 Java 虚拟机栈，Java 虚拟机将抛出 `StackOverflowError`。
- 如果 Java 虚拟机栈可以动态扩展，并尝试进行扩展，但可用内存不足以影响扩展，
  或者如果可用内存不足以为新线程创建初始 Java 虚拟机栈，Java 虚拟机将抛出 `OutOfMemoryError`。

### 堆

Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的堆。堆是分配所有类实例和数组的内存的运行时数据区域。

堆是在虚拟机启动时创建的。
存储对象的堆内存，由自动存储管理系统(称为垃圾收集器, garbage collector)回收。
对象从不显式释放。
Java 虚拟机没有特定类型的自动存储管理系统，可以根据实现者的系统需求选择存储管理技术。
堆的大小可以是固定的，也可以根据计算的需要进行扩展，如果不需要更大的堆，则可以缩小堆。堆的内存不需要是连续的。

Java 虚拟机实现可以为程序员或用户提供对堆初始大小的控制，如果堆可以动态扩展或收缩，还可以控制堆的最大和最小大小。

下列异常情况与堆相关联:

- 如果计算所需的堆超过了自动存储管理系统所能提供的堆，Java 虚拟机将抛出 `OutOfMemoryError`。

### 方法区

Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区。
方法区类似于传统语言的编译代码的存储区域或类似于操作系统进程中的“文本”段。
它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，
包括类和接口初始化以及实例初始化中使用的特殊方法。

方法区域是在虚拟机启动时创建的。
尽管方法区域在逻辑上是堆的一部分，但是简单的实现可以选择不对其进行垃圾收集或压缩。
此规范不强制要求方法区域的位置或用于管理已编译代码的策略。
方法区域可以是固定大小的，也可以根据计算的需要扩大，并且如果不需要更大的方法区域，可以缩小。
方法区域的内存不需要是连续的。

Java 虚拟机实现可以为程序员或用户提供对方法区域的初始大小的控制，以及在方法区域大小不同的情况下，对最大和最小方法区域大小的控制。

下列异常情况与方法区域相关联:

- 如果方法区域中的内存不能用于满足分配请求，Java 虚拟机将抛出 `OutOfMemoryError`。

### 运行时常量池

运行时常量池是 class 文件中 `constant_pool` 表的每个类或每个接口的运行时表示形式。
它包含几种常量，从编译时已知的数字字面量到运行时必须解析的方法和字段引用。
运行时常量池的功能类似于传统编程语言中的符号表，但它包含的数据范围比典型的符号表更广。

每个运行时常量池都是从 Java 虚拟机的方法区分配的。类或接口的运行时常量池是在 Java 虚拟机创建类或接口时构造的。

下列异常情况与类或接口的运行时常量池的构造相关联:

- 当创建一个类或接口时，如果运行时常量池的构造需要比 Java 虚拟机的方法区域更多的内存，Java 虚拟机将抛出一个 `OutOfMemoryError`。

### 本地方法栈

Java 虚拟机的实现可以使用传统的堆栈，俗称“ C 堆栈”，来支持本地（native）方法(用 Java 编程语言以外的语言编写的方法)。
本地方法栈也可以用于 Java 虚拟机指令集的解释器的实现，例如 C 语言。
Java 虚拟机实现不能加载本地方法，而且不依赖于常规栈，因此不需要提供本地方法栈。
如果提供了本地方法堆栈，则通常在创建每个线程时为每个线程分配本地方法堆栈。

## 帧

框架用于存储数据和部分结果，以及执行动态链接、方法的返回值和分派异常。

每次调用方法时都会创建一个新的帧。帧在其方法调用完成时被销毁，无论是正常结束的，还是被打断的(它抛出未捕获的异常)。
帧是在创建帧的线程的 Java 虚拟机栈中分配的。每个帧都有自己的局部变量数组、自己的操作数栈
和一个到当前方法所在类常量池的引用。

局部变量数组和操作数栈的大小是在编译时确定的，并且与帧关联的方法的代码一起提供。
因此，帧数据结构的大小仅取决于 Java 虚拟机的实现，而且这些结构的内存可以在方法调用同时分配。

在线程执行的的任何时间点上，只有一个帧(执行方法的帧)处于活动状态。
此帧称为当前帧，其方法称为当前方法。定义当前方法的类是当前类。局部变量和操作数堆栈上的操作通常与当前帧有关。

如果一个框架的方法调用了另一个方法，或者它的方法完成了，那么它就不再是当前的框架。
当调用方法时，将创建一个新框架，并在控件传输到新方法时成为当前框架。
在方法返回时，当前框架将其方法调用的结果(如果有的话)传回给前一个框架。当前帧随后被丢弃，因为前一帧变成了当前帧。

请注意，由线程创建的帧由该线程独享，不能被任何其他线程引用。