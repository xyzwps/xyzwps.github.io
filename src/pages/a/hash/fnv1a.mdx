---
layout: ./_BlogLayout.astro
title: FNV-1a Hash
---

## FNV-1 Hash

FNV 哈希算法的基础来自于 1991 年 Glenn Fowler 和 Phong Vo 在 IEEE POSIX P1003.2
委员会上发表的评论。在随后的一轮投票中: Landon Curt Noll 改进了他们的算法。
有些人尝试了这个算法，发现效果相当不错。在给 Landon 的一封电子邮件中，他们将其命名为
“Fowler/Noll/Vo” 或 FNV 哈希。

FNV 哈希在设计上，计算速度快，同时保持低碰撞率。FNV 可以快速散列大量的数据，同时保持一个合理的碰撞率。
FNV 哈希的高分散性使它们非常适合哈希几乎相同的字符串，如 URL、主机名、文件名、文本、IP 地址等。

FNV-1 哈希算法核心如下：

```
hash = offset_basis
for each octet_of_data to be hashed
    hash = hash * FNV_prime
    hash = hash xor octet_of_data
return hash
```

其中：

- `hash` 是一个 $n$ 位无符号整数。换句话说，$n$ 是 `hash` 的比特长度。
- 执行乘法后，对结果除 $2^n$ 取模。
- `xor` 只在 `hash` 的低 8 位进行。
- **_`FNV_prime`_** 的取值与 $n$ 有关：
  | $n$ | **_`FNV_prime`_** |
  |----|----|
  | 32 | $2^{24} +  2^{8} + 0\text{x93} = 16777619$ |
  | 64 | $2^{40} +  2^{8} + 0\text{xb3} = 1099511628211$ |
  | 128 | $2^{88} +  2^{8} + 0\text{x3b} = 309485009821345068724781371$ |
  | 256 | $2^{168} +  2^{8} + 0\text{x63} = 374144419156711147060143317175368453031918731002211$ |
  | 512 | $2^{344} +  2^{8} + 0\text{x57} = 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759$ |
  | 1024 | $2^{680} +  2^{8} + 0\text{x8d} = 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573$ |

  FNV 的一个神奇之处在于为给定长度的 `hash` 选取 $\text{FNV\_prime}$。在哈希时，有些质数的表现比其他质数更好。

- 其中 $\text{offset\_basis}$ 的取值也依赖于 $n$：
  | $n$ | **_`offset_basis`_** |
  |-----|----------------------|
  | 32 | 2166136261 |
  | 64 | 14695981039346656037 |
  | 128 | 144066263297769815596495629667062367629 |
  | 256 | 100029257958052580907070968620625704837092796014241193945225284501741471925557 |
  | 512 | 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785 |
  | 1024 | 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915 |

  这些非零整数都是以下 32 字节字符串的 FNV-0 哈希值：

  ```
  chongo <Landon Curt Noll> /\../\
  ```

  注意，它不是那些 `\` 不是 C 风格的转义字符。C 风格的写法如下：

  ```c
  "chongo <Landon Curt Noll> /\\../\\"
  ```

  注意，上面的字符串长度是 31，之所以说是 32 字节字符串，是因为在 C 中，字符串用字符数组存储，最后一位存数字 0。补上数字 0 之后，就是 32 字节了。。。

  这里所谓 FNV-0，是指 **_`offset_basis`_** 的初始值是 0 的 FNV 哈希。已经被废弃。

可以看到他们对 **_`offset_basis`_** 的选择挺那啥的。但是对 **_`FNV_prime`_**
的选择就很魔法了，如果你感兴趣，可以在参考文档 [FNV Hash](http://www.isthe.com/chongo/tech/comp/fnv/)
中查看相关的说明，这里就不献丑了。

## FNV-1a Hash

它和 FNV-1 在算法上的区别是乘法和异或的执行顺序。算法如下：

```
hash = offset_basis
for each octet_of_data to be hashed
    hash = hash xor octet_of_data
    hash = hash * FNV_prime
return hash
```

FNV-1a 算法的各参数和 FNV-1 一致。

有些人使用 FNV-1a 而不是 FNV-1，因为他们发现对于小内存块（小于 4 字节），其分散性稍好一些。

现在推荐使用 FNV-1a 而不是 FNV-1。

## 现成的实现

在 javascript 界，有 [sindresorhus/fnv1a](https://github.com/sindresorhus/fnv1a)。

在 java 界，我搜到了两个用 `BitInteger` 实现的算法，感觉跟自己手写也差不多了。

## 参考

- [FNV Hash - Landon](http://www.isthe.com/chongo/tech/comp/fnv/)
