---
title: 如何在数据库中安全地存密码
date: 2022-12-06
---

本文洗自[How to Securely Store Passwords in Database?](https://www.vaadata.com/blog/how-to-securely-store-passwords-in-database/)。
你若有能力，那么你应该去查看原文。

安全地存储密码是一个反复出现的问题。不过，主要方法是什么？它们是如何工作的？它们对抗当前的密码破解技术？
在本文中，我们解释了安全存储的主要原则(hash、 salt、 pepper、迭代) ，并强调了它们对于抵抗密码恢复方法的重要性。
最后，我们将讨论一个用于安全存储的可靠散列函数。

# 纯文本密码

假定攻击者偷了你的数据库，从中提取出了一些用户名和密码：

| Login      | Password          |
|:-----------|:------------------|
| `admin`    | `azerty`          |
| `toto`     | `matrix`          |
| `billy`    | `yep59f$4txwrr`   |
| `tata`     | `matrix`          |
| `titi`     | `freepass`        |
| `attacker` | `tesPwndPassword` |

这种情况下，攻击者可以得到所有用户的密码明文。即使 *billy* 的密码很强，也冇用。

所以，以纯文本存储密码不是一种安全的解决方案。**任何人，包括网站/数据库管理员，都不应该访问用户的纯文本密码**。

# 加密过的密码

在某些场景下，用可逆算法（rot13，掩码加密...）加密后，把密码存储在数据库中。
由于该算法是可逆的，因此不符合法国国家信息与自由委员会(CNIL)的规定（注意，本文是翻译）。

***事实上，它推荐任何密码都应用不可逆的加密函数进行转换***。

攻击者知道以加密形式输入的密码，他就可以猜测加密逻辑，并尝试恢复它。
如果他成功了，无论算法多复杂，所有密码都将像纯文本一样快速地被检索到。

# 过时的 Hash 函数

在许多情况下，密码使用过时的不可逆加密函数(md5、 sha1...)存储。
例如，LinkedIn 曾将部分密码存储在 sha1中，2012年 hash 泄露后，恢复90% 的密码只花了三天时间。

我们考虑下面的数据库(密码与前面的相同)：

| Login      | Password (md5)                     |
|:-----------|:-----------------------------------|
| `admin`    | `ab4f63f9ac65152575886860dde480a1` |
| `toto`     | `21b72c0b7adc5c7b4a50ffcb90d92dd6` |
| `billy`    | `47ad898a379c3dad10b4812eba843601` |
| `tata`     | `21b72c0b7adc5c7b4a50ffcb90d92dd6` |
| `titi`     | `5b9a8069d33fe9812dc8310ebff0a315` |

注意到：

- 在我们的例子中，所有的密码(除了 Billy 的)都是非常常用的密码，并且是最常用的密码之一
  (例如在[1000万个密码列表的 top-1000.txt](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/10-million-password-list-top-1000.txt)中)。
- 值得注意的是，由于散列没有随机性的概念，因此 toto 和 tata 共享相同的散列，因为它们有相同的密码。

很容易就能用搜素引擎直接搜索到他们的密码。

![cache aside](/asset/img/hash-md5-ab4f6.png)

除了使用复杂密码的用户 Billy 之外，可以通过搜索引擎中的查询直接检索所有散列。

如果在搜索引擎中没有直接找到散列，攻击者还有其他方法:

## 暴力攻击 (Brute force attack)

暴力法是按照生成规则迭代地试验所有可能性的行为。
这就像我们试图通过列出从 0000 到 9999 的所有可能性来打开挂锁，直到锁打开。

## 字典攻击 (Dictionary attack)

你可以用一个字典列出所有术语。可以想象下列几种字典：

* 语言词典
* 最常用密码的排名
* 一个适合给定上下文的列表

对于挂锁，我们可以想象一个这样的上下文列表：

*我们知道挂锁是“Tutu”的，他喜欢 42 这个数字，他出生于 2001 年 11 月 26 日。因此，*
*我们可以假设挂锁可能包含数字 42、26、11 和 01，从而根据这些条件生成一个列表。*

注意: 因为语言的滥用，字典攻击常常被称为暴力攻击。

## 彩虹表 (Rainbow table)

彩虹表是一个值得单写一篇文章的主题。
简单说，它是一个数据结构，允许在一种很好的存储/时间折中下检索密码。 TODO: 重新描述
此结构有一个预先计算哈希列表，可以在可接受的时间内检索哈希。

网上有许多彩虹表。

## 得到 Md5 密码的基准测试

它是一种在数据库上执行的基准测试，使用了 rockyou 列表，其中包含 14,341,564 个独特的密码。
基准测试是在虚拟机上执行的，这对于破解密码来说并不是最佳选择。

![cache aside](/asset/img/md5-benchmark-rockyou.png)

如图，我们发现除了不在 rockyou 列表中的 Billy 的密码之外，所有三个密码都已经找到，而且只需要 11 秒，
该软件就可以计算 rockyou 中的所有散列。

# 不合适的 Hash 函数

在看过前面的糟糕示例之后，我们倾向于使用像 sha256、 sha512 或 sha3 这样的安全不可逆函数。
然而，这些函数的目的是用于计算加密汇总，以检查文件的完整性，制作电子签名，或优化搜索和索引。
它们不适合存储密码，因为它们计算速度很快，下面的基准测试证明了这一点:


| Login   | Password (sha512)  |
|:--------|:-------------------|
| `admin` | `df6b9fb15cfdbb7527be5a8a6e39f39e572c8ddb943fbc79a943438e9d3d85ebfc2ccf9e0eccd9346026c0b6876e0e01556fe56f135582c05fbdbb505d46755a` |
| `toto`  | `11a25e88658143a853d280bf77f81ff391347aaba2db54a3aab0149b265276de419880762a473fc496388bcf70566d7cfd0346c34add40652f8f7b669caf9ec0` |
| `billy` | `fe9cb9b07725fd1cc3906232405119fedf9a020436630d3c1e0f632f73909e6ed9e731c149ac22743bbe9541881f35ceebf1d2782d469eb3b42968469d55a7a4` |
| `tata`  | `11a25e88658143a853d280bf77f81ff391347aaba2db54a3aab0149b265276de419880762a473fc496388bcf70566d7cfd0346c34add40652f8f7b669caf9ec0` |
| `titi`  | `f767036acd951f5ddaf4eed5291c677db060055806dbcae69ca35d95847559dc8abce5011fd2b50833e760eca2d84d6daf1f078200f42b4fc10b58bad3761c88` |

![cache aside](/asset/img/hashcat-1-1536x719.png)

在这里，除了用户 Billy 之外，所有的密码都已经被检索，Hashcat 完成操作只需要16秒。

# 改进 sha512

即使早些时候已经说过 SHA512 函数没有针对密码存储进行优化，
展示如何对其进行优化以理解适当的密码散列函数的意义也是很有趣的。

## 加盐

盐（*salt*）是原始数据(这里是密码)的污染物，允许从相同的数据生成两个不同的散列。
盐对于每个用户都是唯一的，它由一个随机序列组成。
它增加了密码唯一的可能性，因此也增加了从未使用过散列的可能性。

例如，加盐后，toto 和 tata 在数据库中就可以有不同的 hash。

加盐的好处有：

1. 如果加了盐，几乎不可能直接在互联网上找到 hash。不过，盐必须足够长且随机。
1. 彩虹表不适用于加盐的 hash。
1. 如前所述，如果加盐，密码相同的两个用户将有不同的 hash。
   密码破解软件(hashcat，Johntheripper...) ，在破坏 hash 之后，查看是否其他用户没有使用它。
   因此，不加盐，在发现 toto 的密码后，能够直接发现 tata 的密码。
   但是，对于每个用户，软件必须从头开始。

**加盐后的基准测试**

| User    | `Salt`                   | `Hash sha512 with salt` |
|:--------|:-------------------------|:------------------------|
| `admin` | `BGdd6d6^ZgvkMhKf@W3RqT` | `7509d123bce1aa92331861cf8fd738a58205045123f0e25f0862477cb19d3ee0757cd99865c30b123ad1e7f1be1e31a6058090458cb9941031f5c36683c8446e` |
| `toto`  | `HZBD^@gL*wvoExo6yJ7hVB` | `6b28830776de6ad7ef1dd8c221e0d53fec4532c623075d0216d937ab82ab284a56a461ce5d4ec77d1783665a262a6a1eb98627b1f6260da55dbb782d7cb75bc4` |
| `billy` | `wvVndjwcZJy!dwT4fBD@U^` | `2847b2605f6a1cd88399e6c9784c0e583799be9485cb128fe5f541f43636559067ec32de33e9b3fa2c15b15eec294cf262fd7aab2395dd64d6dbd9640b4fe6fd` |
| `tata`  | `QeNWm9NXqJ8m@m2^F7Kh9*` | `165bc06b69fa2bfcd893bfde86358394406c87c7f7abba891cd10ed9fac887c54d52ed14310ad675078033e9bca80084d345fb2836933e55c60f734982430e2b` |
| `titi`  | `iQUemgw9M6Gw*&v6RG%MZ#` | `f8eded6c815c7522ab6197aa319d3ff4cddc2c7eeffa0f91c1291603f807a47f320324d2ce2fed1fb3cbfe19524fc5d9c105093f755d76a949efb212fb85c942` |

使用这种配置，hashcat 软件恢复密码需要33秒。
数据库中的哈希值没有一个是能够通过搜索引擎搜索到的。

# 加胡椒

胡椒也是一种污染物，但对所有使用者都是普遍存在的。
它不存储在数据库中，而是存储在应用程序的源代码、配置文件或环境变量中。
攻击者“刚刚”理解了一个数据库，必须猜测胡椒或以另一种方式检索它，以便能够有效地破坏散列。

# 增加迭代次数

增加安全性的另一种方法是重复散列的迭代次数。增加迭代次数意味着我们要对密码进行多次哈希。
例如，对于 sha512，我们有以下循环:

```
As long as iteration is greater than 0
    hash = sha512(hash)
    Decrement iteration
```

对于登录的用户来说，哈希的计算时间会更长(仍然需要一毫秒)。
但是如果用户失去了几毫秒的登录时间，那么攻击者就会失去更多的时间，因为攻击者每次尝试都会失去几毫秒，
而且由于攻击者进行了数百万次尝试，这将导致额外的小时/天来检索密码。

# 合并这三种方法

我们可以合并这三个方法(salt、 pepper 和迭代次数) ，使用一个方法比简单的 hash 更安全地存储密码。

```
Function calculation_hash(password,salt,pepper,iteration)
Inputs
  password is the user's password in plain text
  salt is the unique salt per user and is randomly generated
  pepper is the common pepper for all users and is randomly generated.
  iteration is the number of iterations

Output:
  The password hash
  Hash = sha512(salt+password+pepper)
  As long as iteration is greater than 0
  hash = sha512(hash)
  Decrement iteration

return hash
```

然后，要在登录时检查密码，只需调用用户输入的密码的相同函数，并将其与数据库中的散列进行比较。如果两者相同，则登录成功。

# 使用特定函数

在此之前，我们设法创建了一个生成哈希值的算法，这种算法对密码破解软件更有抵抗力。
然而，有些函数已经存在，并且随着时间的推移已经证明了它们的有效性。
因此，重新发明车轮并冒引起错误的风险是无用的。
在这些不同的功能中，我们可以找到: Argon2，scrypt，PBKDF2，bcrypt...

这些函数有很多优点：

* 算的慢
* 更加的 RAM 密集型(这是 GPU 的弱点)
* 定义所使用的加密函数的迭代次数。如前所述，迭代次数越多，计算成本就越高。

## Bcrypt

Bcrypt 是由 Niels Provos 和 David Mazières 创建的散列函数。它基于 Blowfish 加密算法，并于1999年在 USENIX 上提出。

除了上面提到的这些积极的方面之外，我们还发现了许多语言的实现。
此外，由于这个算法可以追溯到1999年，它已经显示了随着时间的推移其鲁棒性，其中一些算法，如 Argon2(i)只存在于2015年。

Bcrypt 计算的 hash 具有预定义的形式:

***`$2y$11$SXAXZyioy60hbnymeoJ9.ulscXwUFMhbvLaTxAt729tGusw.5AG4C`***

1. **算法**: 这个版本可以根据 bcrypt 的版本($2 $，$2a $，$2x $，$2y $和 $2b $)采用多个版本
1. **成本**: 幂为2的迭代次数。例如，这里的迭代是11次，算法将执行2^11次迭代(2048次迭代)。
1. **盐**: 与将 salt 存储在专用列中不同，它直接存储在最终散列中。
1. **哈希后的密码**

由于 bcrypt 存储迭代次数，这使它成为一个自适应函数，因为迭代次数可以增加，因此它越来越长。
这使得它，尽管它的年龄和计算能力的演变，仍然能够抵御暴力攻击。
下面的基准测试表明，hashcat 需要23天来计算 rockyou 散列的总量。

![cache aside](/asset/img/bcrypt-1.png)

值得注意的是，密码 azerty 和 matrix 是非常弱的密码，位于列表的顶部，它们是在示例中软件工作的短时间(2小时)内发现的。

# 结论

在本文中，我们已经看到了健壮散列函数的有用性以及使用已经存在的函数的优点。
此外，除了安全问题之外，密码存储问题还存在法律问题。

最后，值得注意的是，在所有情况下，密码 azerty 和 Matrix 都很快被找到，而密码 yep59f $4txwrr 从未被找到。
实际上，由于这个字符不在任何列表中，找到它的唯一方法是对13个字符执行彻底的蛮力操作，
这是一个非常耗时的操作(由于大量的密码可能性)。这也说明了强制使用强密码策略对 web 应用程序的重要性。

-----------

# 相关文档

- [How to Securely Store Passwords in Database?](https://www.vaadata.com/blog/how-to-securely-store-passwords-in-database/)