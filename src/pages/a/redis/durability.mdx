---
title: 持久化在说什么
date: 2022-01-11
---

本文对持久化的含义、过程，以及持久化过程中可能会遇到的问题做一个简单介绍。

## 操作系统与磁盘

我们首先要考虑的事情是，我们对数据库中的术语——“**持久性**”（*durability*）应该怀有怎样的期待。为此，我们需要了解一个简单的写操作期间究竟发生了什么：

1. 客户端发送一个写命令到数据库（这时数据在客户端内存中）；
1. 数据库收到写请求（这时数据在数据库服务器内存中）；
1. 数据库发起系统调用把数据写到磁盘上（这时数据在操作系统的内核 buffer 中）；
1. 操作系统把写 buffer 发送到磁盘控制器（这时数据在磁盘缓存中）；
1. 磁盘控制器真正把数据写到物理媒介上（磁盘、闪存芯片等等）

> 注意：上面的描述有些**过于简化**了，因为还有很多层的缓存和 buffer 没有提。
>
> 第 2 步经常被实现为数据库内部的一个复杂的缓存系统，有时写操作会被不同的线程或进程处理。不管怎样，数据库都必须把数据写到磁盘上，这才是我们的视角中重要的事。换句话说，在某个时间点，数据会被传输到操作系统内核（第 3 步）。
>
> 另一个大的简化是第 3 步中的细节，现实远比这复杂。大多数先进的的内核都实现了不同层级的缓存，通常有文件系统层级的缓存（Linux 中叫页面缓存），和一个更小的 *buffer 缓存*，即用一个 buffer 临时存储那些等着被提交到磁盘的数据。使用特殊的 API 可以绕过上面两个缓存。不过从我们的视角来看，我们可以认为这是一个唯一的不透明缓存（即我们不知道细节）。当数据库已经实现了自己的缓存时，页面缓存通常会被禁用，以避免数据库和内核在同一时间尝试做相同的工作（导致不好的结果）。Buffer 缓存通常不会被关掉，因为关掉的话，每次写文件都会导致数据被提交到磁盘，这对大多数应用程序来说都太慢了。
>
> 数据库通常仅在确实需要时，才会发起系统调用把 buffer 缓存中的数据提交到磁盘。

## 什么时候写操作是安全的？

如果我们仅考虑数据库软件的失败（比如进程系统管理员杀掉，或者崩溃了）而不触及内核，那么只要第 3 步成功完成，我们就可以认为写是安全的。此步骤之后，即使数据库进程崩溃了，内核依旧会把数据传输到磁盘控制器。

如果我们考虑更加悲催的事件，比如断电，那么只有第 5 步完成才算安全，即数据真的被传输到物理媒介上。

可以说，对数据安全最重要的是第 3、4、5 步。即：

* 数据库软件多久来一次写系统调用，把它的用户空间 buffer 传输到内核空间 buffer？
* 内核会多久来一次把 buffer 刷到磁盘控制器？
* 磁盘控制器会多久把数据写到物理媒介一次？

> 注意：当我们说*磁盘控制器的时候*，我们实际的意思是由控制器或者磁盘自己做的缓存。在持久化非常重要的系统中，管理员通常会把这个层面的缓存关掉。
>
> 在大多数系统中，磁盘控制器默认仅通过缓存执行写操作。仅当你有电池，或者一个超级电容设备在停电时保护数据的情况下，打开写回模式（写缓存）才安全的。

## POSIX API

从数据库开发者的角度看，数据被实际写入物理设备之前遵循的路径很有趣，更有趣的是这个路径上编程 API 提供的*控制数量*（TODO: ???）。

我们从第 3 步开始。我们使用*写*操作系统调用来把数据传输到内核 buffer，从这个角度看，我们使用 POSIX API 可以对此有一个很好的控制。不过，我们并不能控制这个系统调用要花多久才会成功返回。内核的写 buffer 大小是有限制的，如果磁盘不能应对应用程序的写带宽，那么内核写 buffer 就被写满，内核就会阻塞写操作。当磁盘能够接收到更多数据时，写系统调用才会返回。总之，目标是最终把数据写到物理媒介中。

在第 4 步中，内核把数据传送给磁盘控制器。通常操作系统会避免频繁这么做，因为大块地传输数据会更快。比如，Linux 默认会在 **30 秒**后才提交写操作。这意味着，一旦失败，最后 30 秒写的所有数据都可能会丢失。

POSIX API 提供了一族系统调用来强制内核把 buffer 写到磁盘：最有名的系统调用大概就是 *`fsync`* 了（可以在 *msync* 和 *fdatasync* 里查看更多信息）。使用 `fsync`，数据库系统就可以强制内核真的把数据提交到磁盘，不过你可以猜到，这是一个很昂贵的操作：每次被调用时，**`fsync` 都会初始化一个写操作**，导致有一些数据在内核 buffer 中待处理。`fsync` 也会一直阻塞进程来完成写操作，在 Linux 上甚至会阻塞所有其他线程来避免写同一个文件。

## 我们不能控制什么？

现在，我们学会了控制第 3 步和第 4 步，那第 5 步呢？坦白说，我们没办法使用 POSIX API 来控制这一步。可能有些内核实现会尝试告诉驱动器真地把数据提交到物理媒介上，或者控制器可能会为了速度，重排写操纵，导致数据没有被尽快写到磁盘上，而是等了几毫秒。这超出了我们的控制范围。

下面我们把场景限制为两个数据安全级别：

* 使用 `write(2)` 系统调用（或其他等价的方式）把数据写到内核 buffer 中，保证进程失败时的数据安全。
* 使用 `fsync(2)` 系统调用（或其他等价的方式）把数据提交到磁盘，保证操作系统挂掉（比如断电）时的数据安全。我们当然知道这并不能完全保证数据安全，因为磁盘可能会有控制器缓存，不过我们不打算朝这方面考虑，因为这对于所有的数据库系统来说，都有这样的问题。另外，系统管理员通常会有专门的工具来精确控制物理设备的行为。


> 注意：不是所有的数据库都使用 POSIX API。有些专用数据库会使用能够更加直接地和硬件打交道的内核模块。不过总体上，遇到的问题还是一样的。你可以使用用户空间 buffer、内核 buffer，不过数据只有写到磁盘上才真的安全（而这个操作通常很慢）。Oracle 就是使用内核模块。

## 数据崩溃

前面，我们在较高的层级——应用和内核——上分析了确保数据真的被传输到磁盘的问题。不过持久性并不仅考虑这些。接下来的问题是：如何保证数据库在灾难性时间发生后的可读性，或者数据内部结构因为某些原因崩溃了导致数据不能再被正确地读取，或者进行数据恢复来重建一个有效的数据表示？

很多 SQL 和 NoSQL 数据库实现了某种形式的磁盘上的树形数据结构用于存储数据和索引。这种数据结构在写的时候进行维护。如果在写操作的过程中系统停止工作了，树的表示还正确么？

一般地，在数据崩溃时有三个层面的安全：

* 数据库在往磁盘写数据的时候不关心失败时发生了什么，要求用户使用副本（*replica*）来恢复数据，或/并提供工具尽可能重建数据。
* 数据库系统使用一个日志记录操作，这样在失败后可以从日志中恢复一致的状态。
* 数据库系统绝不修改已经写入的数据，而是仅工作在*仅追加模式*，这样就不会崩溃。（可以看到，我们考虑的所谓崩溃，不是磁盘损坏之类的事情，而是程序原因导致的数据损坏）


## 参考



- [Redis persistence demystified](http://oldblog.antirez.com/post/redis-persistence-demystified.html)